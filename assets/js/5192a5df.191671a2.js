"use strict";(self.webpackChunkhwdbg_website=self.webpackChunkhwdbg_website||[]).push([[152],{6680:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>a,default:()=>p,frontMatter:()=>r,metadata:()=>o,toc:()=>d});var i=n(4848),s=n(8453);const r={sidebar_position:1},a="Preliminaries",o={id:"script/preliminaries",title:"Preliminaries",description:"This section discusses the debugger script language implemented in hwdbg.",source:"@site/docs/script/preliminaries.md",sourceDirName:"script",slug:"/script/preliminaries",permalink:"/docs/script/preliminaries",draft:!1,unlisted:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/script/preliminaries.md",tags:[],version:"current",sidebarPosition:1,frontMatter:{sidebar_position:1},sidebar:"tutorialSidebar",previous:{title:"Scripting Language",permalink:"/docs/category/scripting-language"},next:{title:"Script Execution Stages",permalink:"/docs/script/stages"}},c={},d=[];function h(e){const t={code:"code",h1:"h1",p:"p",strong:"strong",...(0,s.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.h1,{id:"preliminaries",children:"Preliminaries"}),"\n",(0,i.jsx)(t.p,{children:"This section discusses the debugger script language implemented in hwdbg."}),"\n",(0,i.jsx)(t.h1,{id:"parsing-custom-scripts",children:"Parsing Custom Scripts"}),"\n",(0,i.jsx)(t.p,{children:"The script engine of the hwdbg consists of a back-end utilizing LL(1) and LALR(1) parsers for optimal efficiency, and a front-end employing a MASM Style syntax with C keywords (such as if, else, for) along with a customizable grammar."}),"\n",(0,i.jsx)(t.p,{children:"User-inputted scripts are parsed in either the PS or an external processor and then directed to the PL. These scripts are scanned by a lexer and parsed into an Intermediate Representation (IR), which is then transmitted via the shared Block RAM over the AXI interface into the PL for execution. Subsequently, a buffer is incrementally populated with the execution results and sent back to the PS using the same shared BRAM. This approach yields significant debugging capabilities and enhancements compared to conventional logic analyzers like Xilinx Integrated Logic Analyzer (ILA) and other methods used in commodity logic analyzers, where commands and scripts are much simpler and with less flexibility. Once the IR is ready, the entire script (IR) is sent into the PL, and the response is transmitted back into the PS, creating a unidirectional flow."}),"\n",(0,i.jsx)(t.p,{children:"It is also feasible to designate a script as the action of an event. In this scenario, the parsed IR script is stored in the BRAM. Upon the triggering of a corresponding event, the IR is executed locally by PL, thereby enhancing the execution performance of the script engine."}),"\n",(0,i.jsx)(t.h1,{id:"co-design-of-software-interpretation-and-hardware-execution",children:"Co-Design of Software Interpretation and Hardware Execution"}),"\n",(0,i.jsx)(t.p,{children:"The interpretation and execution module for user-defined scripts is implemented in separate stages. First, a software-based interpretation engine reads the user-defined scripts and produces a custom Intermediate Representation (IR). This software can run either on the FPGA's Processing System (PS) or on any PC running the debugger. Once the IR is generated, it is sent to the debuggee for hardware-level evaluation."}),"\n",(0,i.jsx)(t.p,{children:"The evaluation is conducted in the Programmable Logic (PL) rather than the PS because hwdbg must support real-time signal evaluation and perform checks against the user script in every clock cycle. Due to potential slow communication between the PL and PS, the script execution engine is implemented in the hardware (PL) to ensure efficient and timely performance."}),"\n",(0,i.jsx)(t.h1,{id:"configure-port-adjustments",children:"Configure Port Adjustments"}),"\n",(0,i.jsxs)(t.p,{children:["Upon generating the debugger hardware, the user is able to specify the exact ",(0,i.jsx)(t.strong,{children:"pin"})," and ",(0,i.jsx)(t.strong,{children:"port"})," configuration. Each ",(0,i.jsx)(t.strong,{children:"pin"})," is considered a single input wire (in VHDL ",(0,i.jsx)(t.code,{children:"STD\\_LOGIC"}),"), while each ",(0,i.jsx)(t.strong,{children:"port"})," consists of multiple pins grouped together to form a meaningful value (in VHDL ",(0,i.jsx)(t.code,{children:"STD\\_LOGIC\\_VECTOR"}),"). Once the configuration is done, the generated debugger contains registers (refers to pins) and pseudo-registers (refers to ports). These pins and ports are accessible through custom script expressions."]})]})}function p(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(h,{...e})}):h(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>a,x:()=>o});var i=n(6540);const s={},r=i.createContext(s);function a(e){const t=i.useContext(r);return i.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),i.createElement(r.Provider,{value:t},e.children)}}}]);