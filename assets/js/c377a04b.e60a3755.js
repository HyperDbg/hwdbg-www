"use strict";(self.webpackChunkhwdbg_website=self.webpackChunkhwdbg_website||[]).push([[5742],{4838:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>s,default:()=>l,frontMatter:()=>o,metadata:()=>a,toc:()=>g});var i=t(4848),r=t(8453);const o={sidebar_position:1},s="hwdbg",a={id:"index",title:"hwdbg",description:"The hwdbg debugger chip generator is a gate-level debugging tool designed to make configurable and synthesizable hardware debuggers for white-box and black-box chip fuzzing, testing, and reverse engineering. The primary goal of hwdbg is to provide control over hardware, enabling monitoring and modification of signals down to the granular level of a single clock cycle. It is written in Chisel and Verilog.",source:"@site/docs/index.md",sourceDirName:".",slug:"/",permalink:"/docs/",draft:!1,unlisted:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/index.md",tags:[],version:"current",sidebarPosition:1,frontMatter:{sidebar_position:1},sidebar:"tutorialSidebar",next:{title:"Getting Started",permalink:"/docs/getting-started"}},d={},g=[];function c(e){const n={a:"a",code:"code",h1:"h1",p:"p",pre:"pre",strong:"strong",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.h1,{id:"hwdbg",children:"hwdbg"}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.strong,{children:"hwdbg"})," debugger chip generator is a gate-level debugging tool designed to make configurable and synthesizable hardware debuggers for white-box and black-box chip fuzzing, testing, and reverse engineering. The primary goal of ",(0,i.jsx)(n.strong,{children:"hwdbg"})," is to provide control over hardware, enabling monitoring and modification of signals down to the granular level of a single clock cycle. It is written in Chisel and Verilog."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"            \u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\r\n     _             _  _             \u2503\r\n    | |_  _ _ _  _| || |_  ___      \u2503\r\n    | . || | | |/ . || . \\/ . |     \u2503\r\n    |_|_||__/_/ \\___||___/\\_. |     \u2503\r\n                          <___'     \u2503\r\n                                    \u2503      \u2571|\u3001\r\n  HyperDbg's chip-level debugger    \u2503     (\u02da\u02ce \u30027\r\n                                    \u2503     |\u3001 \u02dc\u3035\r\n            \u2517\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u251b     \u3058\u3057\u02cd,)\u30ce\n"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"hwdbg"})," is a highly customizable debugger designed to ease hardware debugging by bringing software debugging concepts into the hardware debugging domain. ",(0,i.jsx)(n.strong,{children:"hwdbg"})," aims to help with the complexities associated with debugging hardware, including chips and IP cores. Key features of ",(0,i.jsx)(n.strong,{children:"hwdbg"})," include the ability to step through the hardware design at the clock-cycle level, visualize waveforms, inspect values (e.g., like a logical analyzer), and modify signals. Moreover, it is synthesizable into ",(0,i.jsx)(n.a,{href:"https://github.com/HyperDbg/hwdbg-fpga",children:"FPGAs"})," and has the potential for fabrication into physical chips."]})]})}function l(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>s,x:()=>a});var i=t(6540);const r={},o=i.createContext(r);function s(e){const n=i.useContext(o);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:s(e.components),i.createElement(o.Provider,{value:n},e.children)}}}]);