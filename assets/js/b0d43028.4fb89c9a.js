"use strict";(self.webpackChunkhwdbg_website=self.webpackChunkhwdbg_website||[]).push([[4946],{7239:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>l,contentTitle:()=>d,default:()=>h,frontMatter:()=>t,metadata:()=>c,toc:()=>o});var i=s(4848),r=s(8453);const t={},d="Script Engine & Scripting Language",c={id:"scripting",title:"Script Engine & Scripting Language",description:"This section discusses the debugger script language implemented in hwdbg.",source:"@site/docs/scripting.md",sourceDirName:".",slug:"/scripting",permalink:"/docs/scripting",draft:!1,unlisted:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/scripting.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Hardware Design",permalink:"/docs/design"},next:{title:"Debugging Sensors",permalink:"/docs/sensors"}},l={},o=[{value:"Keywords",id:"keywords",level:2},{value:"Operators",id:"operators",level:2},{value:"Operators Precedence/Priority (Expressions)",id:"operators-precedencepriority-expressions",level:3},{value:"Operator Precedence/Priority (Boolean Expressions)",id:"operator-precedencepriority-boolean-expressions",level:3},{value:"Registers &amp; Pseudo-registers",id:"registers--pseudo-registers",level:2},{value:"Number Prefixes",id:"number-prefixes",level:2},{value:"Comments",id:"comments",level:2},{value:"Escape Characters",id:"escape-characters",level:2},{value:"Functions",id:"functions",level:2},{value:"Registers Assignment",id:"registers-assignment",level:2},{value:"Example 1",id:"example-1",level:3},{value:"Example 2",id:"example-2",level:3},{value:"Example 3",id:"example-3",level:3},{value:"Local Variables Assignment",id:"local-variables-assignment",level:2},{value:"Modify Memory",id:"modify-memory",level:2},{value:"Example",id:"example",level:3},{value:"Conditional Statements",id:"conditional-statements",level:2},{value:"if",id:"if",level:3},{value:"Example (if)",id:"example-if",level:3},{value:"else",id:"else",level:3},{value:"Example (else)",id:"example-else",level:3},{value:"elsif",id:"elsif",level:3},{value:"Example (elsif)",id:"example-elsif",level:3},{value:"Loops",id:"loops",level:3},{value:"Naming convention",id:"naming-convention",level:2},{value:"User-defined Functions",id:"user-defined-functions",level:2},{value:"Function: void",id:"function-void",level:3},{value:"Function: int",id:"function-int",level:3}];function a(e){const n={code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",img:"img",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.h1,{id:"script-engine--scripting-language",children:"Script Engine & Scripting Language"}),"\n",(0,i.jsx)(n.p,{children:"This section discusses the debugger script language implemented in hwdbg."}),"\n",(0,i.jsx)(n.h1,{id:"parsing-custom-scripts",children:"Parsing Custom Scripts"}),"\n",(0,i.jsx)(n.p,{children:"The script engine of the hwdbg consists of a back-end utilizing LL(1) and LALR(1) parsers for optimal efficiency, and a front-end employing a MASM Style syntax with C keywords (such as if, else, for) along with a customizable grammar."}),"\n",(0,i.jsx)(n.p,{children:"User-inputted scripts are parsed in either the PS or an external processor and then directed to the PL. These scripts are scanned by a lexer and parsed into an Intermediate Representation (IR), which is then transmitted via the shared Block RAM over the AXI interface into the PL for execution. Subsequently, a buffer is incrementally populated with the execution results and sent back to the PS using the same shared BRAM. This approach yields significant debugging capabilities and enhancements compared to conventional logic analyzers like Xilinx Integrated Logic Analyzer (ILA) and other methods used in commodity logic analyzers, where commands and scripts are much simpler and with less flexibility. Once the IR is ready, the entire script (IR) is sent into the PL, and the response is transmitted back into the PS, creating a unidirectional flow."}),"\n",(0,i.jsx)(n.p,{children:"It is also feasible to designate a script as the action of an event. In this scenario, the parsed IR script is stored in the BRAM. Upon the triggering of a corresponding event, the IR is executed locally by PL, thereby enhancing the execution performance of the script engine."}),"\n",(0,i.jsx)(n.h1,{id:"co-design-of-software-interpretation-and-hardware-execution",children:"Co-Design of Software Interpretation and Hardware Execution"}),"\n",(0,i.jsx)(n.p,{children:"The interpretation and execution module for user-defined scripts is implemented in separate stages. First, a software-based interpretation engine reads the user-defined scripts and produces a custom Intermediate Representation (IR). This software can run either on the FPGA's Processing System (PS) or on any PC running the debugger. Once the IR is generated, it is sent to the debuggee for hardware-level evaluation."}),"\n",(0,i.jsx)(n.p,{children:"The evaluation is conducted in the Programmable Logic (PL) rather than the PS because hwdbg must support real-time signal evaluation and perform checks against the user script in every clock cycle. Due to potential slow communication between the PL and PS, the script execution engine is implemented in the hardware (PL) to ensure efficient and timely performance."}),"\n",(0,i.jsx)(n.h1,{id:"configure-port-adjustments",children:"Configure Port Adjustments"}),"\n",(0,i.jsxs)(n.p,{children:["Upon generating the debugger hardware, the user is able to specify the exact ",(0,i.jsx)(n.strong,{children:"pin"})," and ",(0,i.jsx)(n.strong,{children:"port"})," configuration. Each ",(0,i.jsx)(n.strong,{children:"pin"})," is considered a single input wire (in VHDL ",(0,i.jsx)(n.code,{children:"STD\\_LOGIC"}),"), while each ",(0,i.jsx)(n.strong,{children:"port"})," consists of multiple pins grouped together to form a meaningful value (in VHDL ",(0,i.jsx)(n.code,{children:"STD\\_LOGIC\\_VECTOR"}),"). Once the configuration is done, the generated debugger contains registers (refers to pins) and pseudo-registers (refers to ports). These pins and ports are accessible through custom script expressions (See Section ",(0,i.jsx)(n.code,{children:"\\ref{regs_and_pseudo_regs}"}),")."]}),"\n",(0,i.jsx)(n.h1,{id:"script-execution-stages",children:"Script Execution Stages"}),"\n",(0,i.jsx)(n.p,{children:"To enable on-the-fly script evaluation, script execution is divided into several stages. Each stage includes multiple flip-flops, with the number of flip-flops equal to the number of input pins. Additionally, each stage contains a small buffer (which could be either SRAM or flip-flop) that holds the specific operation to be performed in that stage."}),"\n",(0,i.jsxs)(n.p,{children:["After the debugger transmits the script buffer to the debuggee (PL), hwdbg configures these small buffers with the details of the actions (operators and values) required for each stage. The evaluation module then advances the registers to the next stage with each clock cycle. At each stage, the input flip-flops are evaluated according to the script, and the values of the pins may be modified based on the script's instructions. Once the execution completes all stages, the final stage passes the flip-flops to the ",(0,i.jsx)(n.em,{children:"Output Policy Stage"})," (Described in Section ",(0,i.jsx)(n.code,{children:"\\ref{sec:output_policy_stage}"}),") before sending them to the output pins. The following figure depicts a 4-stage script evaluation engine. Note that the number of stages is configurable by the hardware engineer. For example, a debugger equipped with more script execution engines can run more operations within a single script, although this results in a larger hardware area (utilized resources in FPGAs)."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{alt:"4-Stage Script Evaluation and Execution Engine.",src:s(8615).A+"",width:"3222",height:"1390"})}),"\n",(0,i.jsx)(n.p,{children:"As mentioned earlier, each execution engine comes with a small buffer (SRAM or Flip-Flop) that contains local operations to that specific stage. This buffer conducts the script evaluation engine on how to behave with the signal at the corresponding stage. The following C structure shows how these local buffers are formed in hwdbg."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"typedef struct SYMBOL {\r\n    long long unsigned Type;\r\n    long long unsigned Len;\r\n    long long unsigned VariableType;\r\n    long long unsigned Value;\r\n } SYMBOL, * PSYMBOL;\n"})}),"\n",(0,i.jsx)(n.h1,{id:"output-policy-stage",children:"Output Policy Stage"}),"\n",(0,i.jsxs)(n.p,{children:["The last stage before sending flop-flops (possibly modified input) is the ",(0,i.jsx)(n.em,{children:"Output Policy Stage"}),". As its name implies this stage decides how outputs should be sent over the wires (pins). For example, some functions are designed to block output (send zero) which in reality these functions change the policy of this stage and influence the output signal. Other than that, functionalities like stepping through the signals (See Section ",(0,i.jsx)(n.code,{children:"\\ref{sec:stepping_emulation}"}),") and pausing the signals (See Section ",(0,i.jsx)(n.code,{children:"\\ref{sec:pausing_debuggee}"}),") are implemented by employing this mechanism. The following figure depicts how this mechanism is connected to the script execution stages."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{alt:"Script Evaluation Stages and Output Policy.",src:s(3581).A+"",width:"1027",height:"1044"})}),"\n",(0,i.jsx)(n.h1,{id:"script-engine",children:"Script Engine"}),"\n",(0,i.jsxs)(n.p,{children:["hwdbg use HyperDbg scripting (",(0,i.jsx)(n.em,{children:"dslang"}),") syntax which is a MASM-like syntax to evaluate script expressions. The ",(0,i.jsx)(n.em,{children:"dslang"})," scripts are case-sensitive and hwdbg-specific keywords and functions start with ",(0,i.jsx)(n.code,{children:"hw\\_"})," prefix."]}),"\n",(0,i.jsx)(n.h2,{id:"keywords",children:"Keywords"}),"\n",(0,i.jsx)(n.p,{children:"The keywords shown below are valid in hwdbg scripts."}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:(0,i.jsx)(n.strong,{children:"Keyword"})}),(0,i.jsx)(n.th,{children:(0,i.jsx)(n.strong,{children:"Description"})})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"poi"}),(0,i.jsx)(n.td,{children:"Pointer-sized data from the specified address (dereference)"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"ref"}),(0,i.jsx)(n.td,{children:"Reference address of the specified variable"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"db"}),(0,i.jsx)(n.td,{children:"Low 8 bits (dereference)"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"hi"}),(0,i.jsx)(n.td,{children:"High 16 bits (dereference)"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"low"}),(0,i.jsx)(n.td,{children:"Low 16 bits (dereference)"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"dw"}),(0,i.jsx)(n.td,{children:"Low 16 bits (dereference)"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"dd"}),(0,i.jsx)(n.td,{children:"Low 32 bits (dereference)"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"dq"}),(0,i.jsx)(n.td,{children:"64 bits (dereference)"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"not"}),(0,i.jsx)(n.td,{children:"Flip each and every bit"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"neg"}),(0,i.jsx)(n.td,{children:"True/False logic flipping"})]})]})]}),"\n",(0,i.jsx)(n.h2,{id:"operators",children:"Operators"}),"\n",(0,i.jsxs)(n.p,{children:["Multiple operators are supported in hwdbg. Note that operators like ",(0,i.jsx)(n.strong,{children:"multiplication"}),", ",(0,i.jsx)(n.strong,{children:"division"}),", and ",(0,i.jsx)(n.strong,{children:"modulus"})," are disabled by default since these operators negatively influence the critical path and decrease the overall supported clock speed. The user might enable these operators by manually configuring the chip generator."]}),"\n",(0,i.jsx)(n.h3,{id:"operators-precedencepriority-expressions",children:"Operators Precedence/Priority (Expressions)"}),"\n",(0,i.jsx)(n.p,{children:"Operator precedence in normal expressions (assignments) is shown in Table below."}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:(0,i.jsx)(n.strong,{children:"Operators"})}),(0,i.jsx)(n.th,{children:(0,i.jsx)(n.strong,{children:"Description"})})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"()"}),(0,i.jsx)(n.td,{children:"Parentheses"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"-+ ~ * &"}),(0,i.jsx)(n.td,{children:"Unary Operators (Unary negative, Unary positive, Bitwise not, Reference, Address of)"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"/ % *"}),(0,i.jsx)(n.td,{children:"Arithmetic Operators (Division, Modulo, Multiplication)"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"+-"}),(0,i.jsx)(n.td,{children:"Arithmetic Operators (Addition, Subtraction)"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"<< >>"}),(0,i.jsx)(n.td,{children:"Shift Operators (Right shift, Left shift)"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"&"}),(0,i.jsx)(n.td,{children:"Bitwise AND Operator"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"^"}),(0,i.jsx)(n.td,{children:"Bitwise XOR Operator (exclusive OR)"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"|"}),(0,i.jsx)(n.td,{children:"Bitwise OR Operator"})]})]})]}),"\n",(0,i.jsx)(n.h3,{id:"operator-precedencepriority-boolean-expressions",children:"Operator Precedence/Priority (Boolean Expressions)"}),"\n",(0,i.jsx)(n.p,{children:"The following table shows operator precedence in boolean expressions."}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:(0,i.jsx)(n.strong,{children:"Operators"})}),(0,i.jsx)(n.th,{children:(0,i.jsx)(n.strong,{children:"Description"})})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"()"}),(0,i.jsx)(n.td,{children:"Parentheses"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"-+ ~ * &"}),(0,i.jsx)(n.td,{children:"Unary Operators (Unary negative, Unary positive, Bitwise not, Reference, Address of)"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"/ % *"}),(0,i.jsx)(n.td,{children:"Arithmetic Operators (Division, Modulo, Multiplication)"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"+-"}),(0,i.jsx)(n.td,{children:"Arithmetic Operators (Addition, Subtraction)"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"<< >>"}),(0,i.jsx)(n.td,{children:"Shift Operators (Right shift, Left shift)"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:">= < > <= == !="}),(0,i.jsx)(n.td,{children:"Comparison operators"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"&"}),(0,i.jsx)(n.td,{children:"Bitwise AND Operator"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"^"}),(0,i.jsx)(n.td,{children:"Bitwise XOR Operator (exclusive OR)"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"|"}),(0,i.jsx)(n.td,{children:"Bitwise OR Operator"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"&&"}),(0,i.jsx)(n.td,{children:"Logical AND"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"||"}),(0,i.jsx)(n.td,{children:"Logical OR"})]})]})]}),"\n",(0,i.jsx)(n.h2,{id:"registers--pseudo-registers",children:"Registers & Pseudo-registers"}),"\n",(0,i.jsxs)(n.p,{children:["Here are the current registers and pseudo-registers supported by the script engine (See Table below). Note that registers (pins) start with '",(0,i.jsx)(n.code,{children:"@"}),"' and pseudo-registers (ports) start with '",(0,i.jsx)(n.code,{children:"\\$"}),"'."]}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:(0,i.jsx)(n.strong,{children:"Registers"})}),(0,i.jsx)(n.th,{children:(0,i.jsx)(n.strong,{children:"Pseudo-registers"})})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"@hw_pin0"})}),(0,i.jsxs)(n.td,{children:[(0,i.jsx)(n.code,{children:"$hw_clk"}),", or ",(0,i.jsx)(n.code,{children:"$hw_clock"}),": 1 or 0"]})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"@hw_pin1"})}),(0,i.jsx)(n.td,{})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"..."})}),(0,i.jsx)(n.td,{})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"@hw_pinX"})}),(0,i.jsx)(n.td,{})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"@hw_port0"})}),(0,i.jsxs)(n.td,{children:[(0,i.jsx)(n.code,{children:"$hw_counter"}),", and ",(0,i.jsx)(n.code,{children:"$hw_clock_edge_counter"})]})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"@hw_port1"})}),(0,i.jsx)(n.td,{})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"..."})}),(0,i.jsx)(n.td,{})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"@hw_portX"})}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"$hw_clock_frequency"})})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"..."})}),(0,i.jsx)(n.td,{})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"@hw_stage"})}),(0,i.jsxs)(n.td,{children:[(0,i.jsx)(n.code,{children:"$hw_stage"}),": Stage number of script"]})]})]})]}),"\n",(0,i.jsx)(n.h2,{id:"number-prefixes",children:"Number Prefixes"}),"\n",(0,i.jsxs)(n.p,{children:["By default, hwdbg interprets the numbers as hex (base 16). If you want to specify other forms of a number, you should use MASM prefixes. In all MASM expressions, numeric values are interpreted as numbers in the current radix (16, 10, or 8). You can override the default radix by specifying the ",(0,i.jsx)(n.code,{children:"0x"})," prefix (hexadecimal), the ",(0,i.jsx)(n.code,{children:"0n"})," prefix (decimal), the ",(0,i.jsx)(n.code,{children:"0t"})," prefix (octal), or the ",(0,i.jsx)(n.code,{children:"0y"})," prefix (binary)."]}),"\n",(0,i.jsx)(n.h2,{id:"comments",children:"Comments"}),"\n",(0,i.jsxs)(n.p,{children:["hwdbg's comments are like C comments. A comment starts with a slash asterisk ",(0,i.jsx)(n.code,{children:"/*"})," and ends with an asterisk slash ",(0,i.jsx)(n.code,{children:"*/"})," and can be anywhere in your program. Comments can span several lines within your C program."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"/* comment goes here */\n"})}),"\n",(0,i.jsx)(n.p,{children:"OR"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"/*\r\n * comment goes here\r\n */\n"})}),"\n",(0,i.jsx)(n.p,{children:"You can create a comment on a single line."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"// comment goes here\n"})}),"\n",(0,i.jsx)(n.h2,{id:"escape-characters",children:"Escape Characters"}),"\n",(0,i.jsxs)(n.p,{children:["Special characters such as ",(0,i.jsx)(n.code,{children:"\\textbackslash n"})," and ",(0,i.jsx)(n.code,{children:"\\textbackslash t"}),", are used to represent special characters like newline and tab within strings. Additionally, hexadecimal representations between strings, like ",(0,i.jsx)(n.code,{children:"\\textbackslash x41\\textbackslash x42\\textbackslash x43"}),", enable the inclusion of specific byte values in a character sequence."]}),"\n",(0,i.jsx)(n.h2,{id:"functions",children:"Functions"}),"\n",(0,i.jsx)(n.p,{children:"hwdbg supports multiple pre-defined functions. In the first release, the functions shown in the table below are supported. Note that, to make the debugger smaller (utilizing fewer resources), hardware engineers can configure it to remove the support for these functions."}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:(0,i.jsx)(n.strong,{children:"Function"})}),(0,i.jsx)(n.th,{children:(0,i.jsx)(n.strong,{children:"Description"})})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"printf"})}),(0,i.jsx)(n.td,{children:"Send an input message to the debugger"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"hw_trigger"})}),(0,i.jsx)(n.td,{children:"Trigger an event"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"hw_block_all"})}),(0,i.jsx)(n.td,{children:"Block sending any output (output zero)"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"hw_unblock_all"})}),(0,i.jsx)(n.td,{children:"Unblock sending any output (output valid)"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"hw_pin_block"})}),(0,i.jsx)(n.td,{children:"Block sending specific pin output (pin output zero)"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"hw_port_block"})}),(0,i.jsx)(n.td,{children:"Block sending specific port output (port output zero)"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"hw_pin_unblock"})}),(0,i.jsx)(n.td,{children:"Unblock sending specific pin output (pin output valid)"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"hw_port_unblock"})}),(0,i.jsx)(n.td,{children:"Unblock sending specific port output (port output valid)"})]})]})]}),"\n",(0,i.jsx)(n.h1,{id:"hardware-scripting",children:"Hardware Scripting"}),"\n",(0,i.jsx)(n.p,{children:"Here different scripting concepts are discussed."}),"\n",(0,i.jsx)(n.h2,{id:"registers-assignment",children:"Registers Assignment"}),"\n",(0,i.jsx)(n.p,{children:"By using a simple lvalue register assignment, a hardware engineer is able to change the value of each pin (register)."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"@register = expression;\n"})}),"\n",(0,i.jsx)(n.h3,{id:"example-1",children:"Example 1"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"@hw_port2 = 0x55;\n"})}),"\n",(0,i.jsx)(n.h3,{id:"example-2",children:"Example 2"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"@hw_port3 = @hw_port2;\n"})}),"\n",(0,i.jsx)(n.h3,{id:"example-3",children:"Example 3"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"if (@hw_pin4 == 0x1) {\r\n    @hw_port3 = @hw_port1 & @hw_pin1 + 12;\r\n}\n"})}),"\n",(0,i.jsx)(n.h2,{id:"local-variables-assignment",children:"Local Variables Assignment"}),"\n",(0,i.jsxs)(n.p,{children:["In ",(0,i.jsx)(n.em,{children:"dslang"}),", all the variables are defined without ",(0,i.jsx)(n.strong,{children:"type"}),", and all of them are considered unsigned 64-bit integers. You can save the results of functions and boolean expressions or results of mathematical calculations alongside 64-bit addresses to the variables."]}),"\n",(0,i.jsxs)(n.p,{children:["The variables can be used as input to other functions or might be used in conditional statements. The following example shows the assigning ",(0,i.jsx)(n.strong,{children:"0"})," to a variable named ",(0,i.jsx)(n.code,{children:"my\\_variable"}),"."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"my_variable = 0;\n"})}),"\n",(0,i.jsx)(n.p,{children:"You can also assign registers (pins) or pseudo-registers (ports) to the variables."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"my_variable = @hw_port2 + 0x10;\n"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"my_variable = @hw_pin2 - @hw_pin12 + 8;\n"})}),"\n",(0,i.jsx)(n.p,{children:"Also, you can assign the results of functions to the variables."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"my_variable = my_function(@hw_port2);\n"})}),"\n",(0,i.jsx)(n.p,{children:"Or, you can decrement or increment variables by one."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"my_variable++;      // equals to my_variable = my_variable + 1;\r\nmy_variable--;      // equals to my_variable = my_variable - 1;\n"})}),"\n",(0,i.jsx)(n.h2,{id:"modify-memory",children:"Modify Memory"}),"\n",(0,i.jsxs)(n.p,{children:["Modifying memory (BRAM memory) is possible using '",(0,i.jsx)(n.strong,{children:"eb"}),", ",(0,i.jsx)(n.strong,{children:"ed"}),", ",(0,i.jsx)(n.strong,{children:"eq"}),"' functions."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"eb"}),": modifies a single ",(0,i.jsx)(n.strong,{children:"byte"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"ed"}),": modifies a ",(0,i.jsx)(n.strong,{children:"dwrod"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"eq"}),": modifies a ",(0,i.jsx)(n.strong,{children:"qword"})," value."]}),"\n",(0,i.jsx)(n.h3,{id:"example",children:"Example"}),"\n",(0,i.jsxs)(n.p,{children:["The following code edits memory (quad-word) at 0x22 and change it to ",(0,i.jsx)(n.code,{children:"0x1234"}),"."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"IsEditApplied = eq(0x22, 0x1234);\n"})}),"\n",(0,i.jsx)(n.h2,{id:"conditional-statements",children:"Conditional Statements"}),"\n",(0,i.jsx)(n.p,{children:"Conditional statements are used to perform different actions based on different conditions."}),"\n",(0,i.jsx)(n.h3,{id:"if",children:"if"}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.em,{children:"if"})," statement executes some code if one condition is ",(0,i.jsx)(n.strong,{children:"true"}),"."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"if (condition) {\r\n  code to be executed if condition is true;\r\n}\n"})}),"\n",(0,i.jsx)(n.h3,{id:"example-if",children:"Example (if)"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:'if (@hw_port3 == 55) {\r\n    printf("The third port is equal to %llx\\n", @hw_port3);\r\n}\n'})}),"\n",(0,i.jsx)(n.h3,{id:"else",children:"else"}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.em,{children:"else"})," statement is executed if the ",(0,i.jsx)(n.em,{children:"if"})," condition is ",(0,i.jsx)(n.strong,{children:"false"}),"."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"if (condition) {\r\n  code to be executed if condition is true;\r\n}\r\nelse {\r\n  if the above condition is false, then else is called;\r\n}\n"})}),"\n",(0,i.jsx)(n.h3,{id:"example-else",children:"Example (else)"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:'if (@hw_port4 == 55) {\r\n    printf("The 4th port is equal to %llx\\n", @hw_port4);\r\n}\r\nelse {\r\n    printf("The 4th port is not equal to 0x55, it is equal to %llx\\n", @hw_port4);\r\n}\n'})}),"\n",(0,i.jsx)(n.h3,{id:"elsif",children:"elsif"}),"\n",(0,i.jsxs)(n.p,{children:["Multiple ",(0,i.jsx)(n.em,{children:"if...else"})," statements can be nested to create an ",(0,i.jsx)(n.em,{children:"elsif"})," clause. Note that there is one ",(0,i.jsx)(n.em,{children:"elsif"})," (in one word) keyword in ",(0,i.jsx)(n.em,{children:"dslang"})," script engine."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"if (condition) {\r\n  code to be executed if condition is true;\r\n}\r\nelsif (condition) {\r\n  code to be executed if elsif condition is true;\r\n}\r\nelse {\r\n  if none of the above conditions are true, then else is called;\r\n}\n"})}),"\n",(0,i.jsx)(n.h3,{id:"example-elsif",children:"Example (elsif)"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:'if (@hw_port5 == 55) {\r\n    printf("@hw_port5 is equal to 0x55\\n");\r\n}\r\nelsif (@hw_port5 == 66) {\r\n    printf("@hw_port5 is equal to 0x66\\n");\r\n}\r\nelsif (@hw_port5 == 77) {\r\n    printf("@hw_port5 is equal to 0x77\\n");\r\n}\r\nelse {\r\n    printf("@hw_port5 is not equal to 0x55, 0x66, 0x77. It is equal to %llx\\n", @hw_port5);\r\n}\n'})}),"\n",(0,i.jsx)(n.h3,{id:"loops",children:"Loops"}),"\n",(0,i.jsx)(n.p,{children:"At the moment, hardware debugging does not support loops. The absence of loop support stems from the fact that executing loops may require additional clock cycles (stages) to iterate through the scripts. However, this is not feasible because hwdbg directly transfers incoming signals (after the stage delay) to the output without allowing for looping. In certain cases, one can achieve loop behavior by explicitly utilizing consecutive statements."}),"\n",(0,i.jsx)(n.h2,{id:"naming-convention",children:"Naming convention"}),"\n",(0,i.jsxs)(n.p,{children:["Using ",(0,i.jsx)(n.em,{children:"snake_case"})," as the naming convention is suggested. However, the user can use any other naming conventions as well."]}),"\n",(0,i.jsx)(n.h2,{id:"user-defined-functions",children:"User-defined Functions"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"dslang"})," functions are defined using the same syntax as the C programming language."]}),"\n",(0,i.jsx)(n.h3,{id:"function-void",children:"Function: void"}),"\n",(0,i.jsxs)(n.p,{children:["This is an example of a function that does not return any value (",(0,i.jsx)(n.em,{children:"void"}),"). This code defines ",(0,i.jsx)(n.code,{children:"my\\_func"})," which prints two integers. It's called with arguments (",(0,i.jsx)(n.strong,{children:"1"}),", ",(0,i.jsx)(n.strong,{children:"2"}),"). Then, it prints the hexadecimal value of variable ",(0,i.jsx)(n.code,{children:"my\\_var"}),", which is ",(0,i.jsx)(n.strong,{children:"79"}),"."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:'  void my_func(int var, int var2) {\r\n    printf("var = %d, var2 = %d\\n", var, var2);\r\n    return;\r\n    printf("this statement is never shown!\\n");\r\n  }\r\n\r\n  //\r\n  // call function\r\n  //\r\n  my_func(1, 2);\r\n\r\n  int my_var = 79;\r\n  printf("%x\\n", my_var);\n'})}),"\n",(0,i.jsx)(n.h3,{id:"function-int",children:"Function: int"}),"\n",(0,i.jsxs)(n.p,{children:["This is an example of functions that return an ",(0,i.jsx)(n.em,{children:"integer"}),". This code defines four functions: ",(0,i.jsx)(n.code,{children:"my\\_func1"}),", ",(0,i.jsx)(n.code,{children:"my\\_func2"}),", ",(0,i.jsx)(n.code,{children:"my\\_func3"}),", and ",(0,i.jsx)(n.code,{children:"my\\_func4"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"my\\_func1"}),": adds ",(0,i.jsx)(n.strong,{children:"1"})," to its argument and prints the result."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"my\\_func2"}),": multiplies its argument by ",(0,i.jsx)(n.strong,{children:"2"})," and prints the result."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"my\\_func3"}),": also multiplies its argument by ",(0,i.jsx)(n.strong,{children:"2"})," and prints the result."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"my\\_func4"}),": calls ",(0,i.jsx)(n.code,{children:"my\\_func1"}),", ",(0,i.jsx)(n.code,{children:"my\\_func2"}),", and ",(0,i.jsx)(n.code,{children:"my\\_func3"}),", then sums their results and prints the total."]}),"\n",(0,i.jsxs)(n.p,{children:["Finally, it calls ",(0,i.jsx)(n.code,{children:"my\\_func4"})," with an argument of ",(0,i.jsx)(n.strong,{children:"2"})," and prints the result."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:'? {\r\n    \r\n  int my_func1(int var1) {\r\n    result = var1 + 1;\r\n    printf("my_func1 %d\\n", result);\r\n    return result;\r\n  }\r\n  \r\n  int my_func2(int var1) {\r\n    result = var1 * 2;\r\n    printf("my_func2 %d\\n", result);\r\n    return result;\r\n  }\r\n  \r\n  int my_func3(int var1) {\r\n    result = var1 * 2;\r\n    printf("my_func3 %d\\n", result);\r\n    return result;\r\n  }\r\n  \r\n  int my_func4(int var1) {\r\n    result = my_func1(var1) + my_func2(var1) + my_func3(var1);\r\n    printf("my_func4 %d\\n", result);\r\n    return result;\r\n  }\r\n\r\n  printf("%d\\n", my_func4(2));\r\n}\n'})}),"\n",(0,i.jsx)(n.h1,{id:"extensions--arguments",children:"Extensions & Arguments"}),"\n",(0,i.jsx)(n.p,{children:"Batch scripts are essential parts of hardware debugging and the script engine and it is mainly used to automate debugging tasks."}),"\n",(0,i.jsx)(n.p,{children:"Based on the complexity of developing different parts of the debugger and the fact that there are tens of considerations on developing automated tasks in hwdbg, it is preferred to use the script engine to implement many features and commands. That is why hwdbg came with a set of pre-defined scripts."}),"\n",(0,i.jsx)(n.p,{children:"Hardware engineers can write their own scripts to automate debugging routines without worrying about hwdbg internals, as most limitations are checked through the script functions."}),"\n",(0,i.jsxs)(n.p,{children:["Hardware engineers can use plain text files for batch scripts, but as the convention, hwdbg uses (",(0,i.jsx)(n.strong,{children:".ds"}),") extensions, the abbreviation of ",(0,i.jsx)(n.strong,{children:"D"}),"ebugger ",(0,i.jsx)(n.strong,{children:"S"}),"cript."]}),"\n",(0,i.jsxs)(n.p,{children:["Arguments are passed to the scripts by using the ",(0,i.jsx)(n.code,{children:"\\$arg0"}),", ",(0,i.jsx)(n.code,{children:"\\$arg1"}),", ",(0,i.jsx)(n.code,{children:"\\$arg2"}),", ..., ",(0,i.jsx)(n.code,{children:"\\$arg100"}),", ..., ",(0,i.jsx)(n.code,{children:"\\$arg1000"})," and so on."]}),"\n",(0,i.jsxs)(n.p,{children:["The first argument (",(0,i.jsx)(n.code,{children:"\\$arg0"}),") is the script's ",(0,i.jsx)(n.strong,{children:".ds"})," file path. Arguments can be both an expression, a constant, or a string. Constants are considered in hex format if no prefix is specified."]})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(a,{...e})}):a(e)}},3581:(e,n,s)=>{s.d(n,{A:()=>i});const i=s.p+"assets/images/exec-stages-and-output-policy-bc9e0a4d719b49061f5f0a88b8598d39.jpg"},8615:(e,n,s)=>{s.d(n,{A:()=>i});const i=s.p+"assets/images/exec-stages-18c89f2fe32bc06618628fb150a1e1fe.jpg"},8453:(e,n,s)=>{s.d(n,{R:()=>d,x:()=>c});var i=s(6540);const r={},t=i.createContext(r);function d(e){const n=i.useContext(t);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:d(e.components),i.createElement(t.Provider,{value:n},e.children)}}}]);