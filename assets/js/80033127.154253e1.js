"use strict";(self.webpackChunkhwdbg_website=self.webpackChunkhwdbg_website||[]).push([[5589],{8209:(e,t,o)=>{o.r(t),o.d(t,{assets:()=>l,contentTitle:()=>r,default:()=>m,frontMatter:()=>s,metadata:()=>a,toc:()=>c});var n=o(4848),i=o(8453);const s={sidebar_position:6},r="BlockRAM (BRAM) Simulator",a={id:"design-internals/bram-simulator",title:"BlockRAM (BRAM) Simulator",description:"To test and debug the hwdbg effectively, a BlockRAM simulator module was developed, filled with sample testing data from a file. As the Chisel language does not directly support BlockRAM components, despite its support for SRAM modules, an 8 KB flip-flop module was created to simulate the behavior of BlockRAM. At the moment 8 KB was proved to be enough to support most of the hwdbg tasks. This module features input/output ports similar to those of Xilinx FPGA BlockRAMs, ensuring compatibility and accurate simulation. The delay characteristics of the BlockRAM were also emulated which allows the testing module to initialize the flip-flops with test data sent from the PS to PL.",source:"@site/docs/design-internals/bram-simulator.md",sourceDirName:"design-internals",slug:"/design-internals/bram-simulator",permalink:"/docs/design-internals/bram-simulator",draft:!1,unlisted:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/design-internals/bram-simulator.md",tags:[],version:"current",sidebarPosition:6,frontMatter:{sidebar_position:6},sidebar:"tutorialSidebar",previous:{title:"Interpreting Module",permalink:"/docs/design-internals/modules/interpreting"}},l={},c=[];function d(e){const t={a:"a",code:"code",h1:"h1",p:"p",pre:"pre",...(0,i.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(t.h1,{id:"blockram-bram-simulator",children:"BlockRAM (BRAM) Simulator"}),"\n",(0,n.jsx)(t.p,{children:"To test and debug the hwdbg effectively, a BlockRAM simulator module was developed, filled with sample testing data from a file. As the Chisel language does not directly support BlockRAM components, despite its support for SRAM modules, an 8 KB flip-flop module was created to simulate the behavior of BlockRAM. At the moment 8 KB was proved to be enough to support most of the hwdbg tasks. This module features input/output ports similar to those of Xilinx FPGA BlockRAMs, ensuring compatibility and accurate simulation. The delay characteristics of the BlockRAM were also emulated which allows the testing module to initialize the flip-flops with test data sent from the PS to PL."}),"\n",(0,n.jsx)(t.p,{children:"In the simulation, the first half of the BlockRAM is dedicated to buffers for data transfer from PS to PL, while the second half is reserved for data transfer from PL to PS. The BlockRAM is divided into two halves to ensure that both the PL and PS do not simultaneously overwrite each other's buffer. During execution, the testing module initializes the flip-flops with test data, simulating the conditions of actual hardware interactions. After the debugger completes its operations, the second half of the BlockRAM is filled with the output data generated by the PL."}),"\n",(0,n.jsxs)(t.p,{children:["To verify the functionality and correctness of the hwdbg, the data in the BlockRAM is displayed and written to a file post-execution. This data is then interpreted based on the communication protocol, with each field's value being shown and separated for clarity. The simulation was executed using ",(0,n.jsx)(t.a,{href:"https://cocotb.org/",children:"cocotb"}),", with ",(0,n.jsx)(t.a,{href:"https://www.veripool.org/wiki/verilator",children:"Verilator"})," and ",(0,n.jsx)(t.a,{href:"http://iverilog.icarus.com/",children:"Icarus"})," serving as the backend tools. This comprehensive testing framework not only validates the hwdbg but also provides insights into the communication and data handling processes."]}),"\n",(0,n.jsx)(t.p,{children:"The following listing is an example of PS/PL shared BlockRAM contents shown in the BRAM simulator."}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{children:"Number of clock cycles spent in debuggee (PL): 0\r\nNumber of clock cycles spent in debuggee (PL): 10\r\nNumber of clock cycles spent in debuggee (PL): 20\r\nDebuggee (PL) interrupted Debugger (PS)\r\n===============================\r\nContent of BRAM after emulation:\r\nAddress of PL to PS communication: mem_128\r\n\r\nPS to PL area:\r\nmem_0:   00000000   | Checksum\r\nmem_1:   00000000   | Checksum\r\nmem_2:   52444247   | Indicator\r\nmem_3:   48595045   | Indicator\r\nmem_4:   00000004   | TypeOfThePacket\r\nmem_5:   00000002   | RequestedActionOfThePacket\r\nmem_6:   00000000   | Start of Optional Data\r\nmem_7:   00000000\r\n...\r\n\r\nPL to PS area:\r\nmem_128: 00000000   | Checksum\r\nmem_129: 00000000   | Checksum\r\nmem_130: 52444247   | Indicator\r\nmem_131: 48595045   | Indicator\r\nmem_132: 00000005   | TypeOfThePacket\r\nmem_133: 00000003   | RequestedActionOfThePacket\r\nmem_134: 00000003   | Start of Optional Data\r\nmem_135: 0000000c\r\nmem_136: 00000009\r\nmem_137: 0000000b\r\nmem_138: 00000000\r\n...\n"})})]})}function m(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,n.jsx)(t,{...e,children:(0,n.jsx)(d,{...e})}):d(e)}},8453:(e,t,o)=>{o.d(t,{R:()=>r,x:()=>a});var n=o(6540);const i={},s=n.createContext(i);function r(e){const t=n.useContext(s);return n.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function a(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),n.createElement(s.Provider,{value:t},e.children)}}}]);