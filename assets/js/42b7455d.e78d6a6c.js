"use strict";(self.webpackChunkhwdbg_website=self.webpackChunkhwdbg_website||[]).push([[1890],{2411:(e,i,n)=>{n.r(i),n.d(i,{assets:()=>d,contentTitle:()=>a,default:()=>h,frontMatter:()=>r,metadata:()=>o,toc:()=>c});var t=n(4848),s=n(8453);const r={},a="Evaluation",o={id:"tests",title:"Evaluation",description:"In this chapter, the impact of the proposed hardware debugger is discussed and the evaluation result between similar tools (Xilinx ILA) is elaborated.",source:"@site/docs/tests.md",sourceDirName:".",slug:"/tests",permalink:"/docs/tests",draft:!1,unlisted:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/tests.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Debugging Sensors",permalink:"/docs/sensors"},next:{title:"Hardware Debugging, Reversing & Fuzzing",permalink:"/docs/usecases"}},d={},c=[{value:"Comparison Overview",id:"comparison-overview",level:2},{value:"Scripting Comparison",id:"scripting-comparison",level:2},{value:"Detailed Analysis",id:"detailed-analysis",level:2}];function l(e){const i={code:"code",em:"em",h1:"h1",h2:"h2",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",...(0,s.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(i.h1,{id:"evaluation",children:"Evaluation"}),"\n",(0,t.jsx)(i.p,{children:"In this chapter, the impact of the proposed hardware debugger is discussed and the evaluation result between similar tools (Xilinx ILA) is elaborated."}),"\n",(0,t.jsx)(i.h1,{id:"the-impact-of-proposed-hardware",children:"The Impact of Proposed Hardware"}),"\n",(0,t.jsx)(i.p,{children:"The introduction of the hwdbg hardware debugger brings significant improvements to the debugging and testing of FPGA designs. One of the primary impacts is the enhanced reliability of the hardware. By enabling the detection of functional anomalies, monitoring output signal states, and utilizing sensor data, hwdbg ensures that even rare issues can be uncovered and addressed. This comprehensive fault detection capability leads to more robust hardware designs that can operate correctly under a wide range of conditions, reducing the likelihood of failures in the field."}),"\n",(0,t.jsx)(i.p,{children:"Moreover, hwdbg improves the security of FPGA designs. Automated fuzzing and fault-injection capabilities allow developers to identify and mitigate potential security vulnerabilities, such as side-channel attacks. By addressing these vulnerabilities early in the development process, hwdbg helps create more secure systems that can mitigate various attack vectors. This approach to security is crucial for applications involving sensitive data and operations, ensuring that the final product is resilient against potential threats."}),"\n",(0,t.jsx)(i.p,{children:"In addition to reliability and security enhancements, hwdbg also boosts development efficiency. The real-time feedback and insights provided by hwdbg streamline the debugging process, allowing developers to quickly identify and resolve issues. This leads to shorter development cycles and faster time-to-market for new products. Despite its powerful capabilities, hwdbg introduces minimal performance overhead and maintains reasonable resource utilization."}),"\n",(0,t.jsx)(i.h1,{id:"comparison-with-xilinx-ila",children:"Comparison with Xilinx ILA"}),"\n",(0,t.jsx)(i.p,{children:"In this section, we compare the debugging capabilities of hwdbg with those of Xilinx Integrated Logic Analyzer (ILA) based on various critical features."}),"\n",(0,t.jsx)(i.h2,{id:"comparison-overview",children:"Comparison Overview"}),"\n",(0,t.jsx)(i.p,{children:"The table provides a comprehensive comparison between hwdbg and Xilinx ILA, focusing on key aspects relevant to hardware debugging and testing in FPGA designs. The comparison addresses functionalities such as logic analysis, speed, event triggering, and the ability to modify signals on-the-fly, among others."}),"\n",(0,t.jsx)(i.h2,{id:"scripting-comparison",children:"Scripting Comparison"}),"\n",(0,t.jsxs)(i.p,{children:["The scripting capabilities of Xilinx ILA and hwdbg highlight significant differences in their approaches to defining and managing trigger conditions within FPGA debugging tools. The Xilinx ILA uses the ",(0,t.jsx)(i.em,{children:"Trigger State Machine"})," (TSM) language, which allows users to define state machines with specific conditions and actions for triggering events. In contrast, hwdbg employs its own domain-specific language (",(0,t.jsx)(i.em,{children:"dslang"}),") for scripting, which provides a more software-like syntax and functionality."]}),"\n",(0,t.jsxs)(i.p,{children:["The TSM script for Xilinx ILA presented here defines a state machine that waits for a timeout condition. If the counter ",(0,t.jsx)(i.code,{children:"\\$counter0"})," reaches a specified value (",(0,t.jsx)(i.code,{children:"16'u2000"}),"), the counter is reset, and a trigger is issued. If another condition ",(0,t.jsx)(i.code,{children:"(xyz >= 23'u456 or abc == 1'b0)"})," is met, the counter is incremented. Otherwise, the counter is reset. This script structure is highly readable for those familiar with state machine concepts, allowing for precise control over the triggering conditions based on signal values and counters."]}),"\n",(0,t.jsxs)(i.p,{children:["In comparison, the hwdbg's ",(0,t.jsx)(i.em,{children:"dslang"})," script uses a more procedural approach similar to typical programming languages. Variables such as ",(0,t.jsx)(i.code,{children:"my\\_val"})," are defined and manipulated directly. The script checks the value of ",(0,t.jsx)(i.code,{children:"my\\_val"})," against a threshold (",(0,t.jsx)(i.code,{children:"0n2000"}),"), resets the value, and triggers an event if the condition is met. Similar to the TSM script, it also increments or resets ",(0,t.jsx)(i.code,{children:"my\\_val"})," based on additional conditions ",(0,t.jsx)(i.code,{children:"(\\$hw\\_port2 >= 0n456 or @hw\\_pin3 == 0)"}),". The use of procedural constructs like ",(0,t.jsx)(i.code,{children:"if"}),", ",(0,t.jsx)(i.code,{children:"elsif"}),", and direct assignments makes the script more intuitive for software developers, easing the learning curve for those transitioning from software to hardware debugging."]}),"\n",(0,t.jsxs)(i.p,{children:["As a result, the TSM language in Xilinx ILA is well-suited for users who prefer a state machine-based approach, offering detailed control over state transitions and conditions. On the other hand, hwdbg's ",(0,t.jsx)(i.em,{children:"dslang"})," provides a more familiar environment for software developers, with a syntax that emphasizes simplicity and direct manipulation of variables and conditions. This makes hwdbg a better choice for those who seek a more flexible and software-like scripting experience in hardware debugging."]}),"\n",(0,t.jsx)(i.p,{children:"A sample TSM script is shown below."}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{children:"state wait_for_timeout:\r\n    if ($counter0 == 16'u2000) then\r\n        reset_counter $counter0;\r\n        trigger;\r\n    elseif ((xyz >= 23'u456) || (abc == 1'b0)) then\r\n        increment_counter $counter0;\r\n    else\r\n        reset_counter $counter0;\r\n    endif\n"})}),"\n",(0,t.jsxs)(i.p,{children:["A sample ",(0,t.jsx)(i.em,{children:"dslang"})," hardware script is provided below."]}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{children:"? my_val = 0;\r\n? {\r\n\tif (my_val == 0n2000) {\r\n\t\tmy_val = 0;\r\n\t\thw_trigger();\r\n\t} elsif (($hw_port2 >= 0n456) || (@hw_pin3 == 0)) {\r\n\t\tmy_val++;\r\n\t} else {\r\n\t\tmy_val = 0;\r\n\t}\r\n}\n"})}),"\n",(0,t.jsx)(i.h2,{id:"detailed-analysis",children:"Detailed Analysis"}),"\n",(0,t.jsx)(i.p,{children:"Logic Analyzer Capabilities: Both hwdbg and Xilinx ILA function effectively as logic analyzers, allowing for the monitoring and capturing of signal activities within FPGA designs. However, the additional features of hwdbg provide more comprehensive debugging tools."}),"\n",(0,t.jsxs)(i.p,{children:[(0,t.jsx)(i.em,{children:"Speed."})," Xilinx ILA outperforms hwdbg in terms of speed, offering faster data capture and processing capabilities. This makes it more suitable for applications where high-speed data acquisition is critical."]}),"\n",(0,t.jsxs)(i.p,{children:[(0,t.jsx)(i.em,{children:"Event Triggering."})," Both tools can trigger events, such as breakpoints, based on specific conditions. This is essential for capturing the state of the system at critical points during operation."]}),"\n",(0,t.jsxs)(i.p,{children:[(0,t.jsx)(i.em,{children:"Debugging Sensors."})," One of the key advantages of hwdbg is its incorporation of debugging sensors. These sensors provide additional insights into the system's performance and can detect anomalies that might not be visible through signal monitoring alone."]}),"\n",(0,t.jsxs)(i.p,{children:[(0,t.jsx)(i.em,{children:"On-the-Fly Signal Modification."})," hwdbg can modify signals on-the-fly, a feature not available in Xilinx ILA. This capability allows for dynamic adjustments and testing of different scenarios without needing to reconfigure the FPGA."]}),"\n",(0,t.jsxs)(i.p,{children:[(0,t.jsx)(i.em,{children:"Complex Computations."})," hwdbg is capable of interpreting complex computations, enhancing its ability to analyze and debug intricate designs. In contrast, Xilinx ILA does not support this level of computational interpretation."]}),"\n",(0,t.jsxs)(i.p,{children:[(0,t.jsx)(i.em,{children:"Configuration and Notifications."})," hwdbg supports on-the-fly configuration changes and can notify the debugger of events without needing a trigger condition. This provides a more flexible and responsive debugging environment compared to Xilinx ILA."]}),"\n",(0,t.jsxs)(i.p,{children:[(0,t.jsx)(i.em,{children:"Software Stepping and Fault Injection."})," hwdbg supports software stepping and fault injection, allowing developers to step through code execution and inject faults to test the robustness of the design. These features are not supported by Xilinx ILA, limiting its debugging capabilities in these areas."]}),"\n",(0,t.jsxs)(i.p,{children:[(0,t.jsx)(i.em,{children:"Scripting and Signal Manipulation."})," The ",(0,t.jsx)(i.em,{children:"dslang"})," scripting in hwdbg is simpler and more intuitive, similar to software-like scripts. This simplicity makes it easier to implement and understand compared to the more complex state machine configurations in Xilinx ILA. Additionally, hwdbg can perform stepping fault injection and signal manipulation using its scripting capabilities and further enhancing its debugging utility."]}),"\n",(0,t.jsxs)(i.p,{children:[(0,t.jsx)(i.em,{children:"Active Debugging."})," hwdbg can actively produce fuzzing signals, a feature not available in Xilinx ILA. This capability is crucial for testing and fuzzing the system's response to unexpected or random inputs, ensuring comprehensive validation of the design."]}),"\n",(0,t.jsxs)(i.p,{children:["The following table depicts the differences between Xilinx TSM and hwdbg ",(0,t.jsx)(i.em,{children:"dslang"}),"."]}),"\n",(0,t.jsxs)(i.table,{children:[(0,t.jsx)(i.thead,{children:(0,t.jsxs)(i.tr,{children:[(0,t.jsx)(i.th,{children:(0,t.jsx)(i.strong,{children:"Feature"})}),(0,t.jsxs)(i.th,{children:[(0,t.jsx)(i.strong,{children:"hwdbg"})," (dslang)"]}),(0,t.jsx)(i.th,{children:(0,t.jsx)(i.strong,{children:"Xilinx ILA (TSM)"})})]})}),(0,t.jsxs)(i.tbody,{children:[(0,t.jsxs)(i.tr,{children:[(0,t.jsx)(i.td,{children:"Can act as a logic analyzer"}),(0,t.jsx)(i.td,{children:"Yes"}),(0,t.jsx)(i.td,{children:"Yes"})]}),(0,t.jsxs)(i.tr,{children:[(0,t.jsx)(i.td,{children:"Speed comparison"}),(0,t.jsx)(i.td,{children:"Slower"}),(0,t.jsx)(i.td,{children:"Faster"})]}),(0,t.jsxs)(i.tr,{children:[(0,t.jsx)(i.td,{children:"Can trigger an event (e.g., a breakpoint)"}),(0,t.jsx)(i.td,{children:"Yes"}),(0,t.jsx)(i.td,{children:"Yes"})]}),(0,t.jsxs)(i.tr,{children:[(0,t.jsx)(i.td,{children:"Has debugging sensors"}),(0,t.jsx)(i.td,{children:"Yes"}),(0,t.jsx)(i.td,{children:"No"})]}),(0,t.jsxs)(i.tr,{children:[(0,t.jsx)(i.td,{children:"Can modify signals on the fly (configurable)"}),(0,t.jsx)(i.td,{children:"Yes"}),(0,t.jsx)(i.td,{children:"No"})]}),(0,t.jsxs)(i.tr,{children:[(0,t.jsx)(i.td,{children:"Can interpret complex computations"}),(0,t.jsx)(i.td,{children:"Yes"}),(0,t.jsx)(i.td,{children:"No"})]}),(0,t.jsxs)(i.tr,{children:[(0,t.jsx)(i.td,{children:"Supports on-the-fly configuration"}),(0,t.jsx)(i.td,{children:"Yes"}),(0,t.jsx)(i.td,{children:"No"})]}),(0,t.jsxs)(i.tr,{children:[(0,t.jsx)(i.td,{children:"Notify the debugger without triggering event"}),(0,t.jsx)(i.td,{children:"Yes"}),(0,t.jsx)(i.td,{children:"No"})]}),(0,t.jsxs)(i.tr,{children:[(0,t.jsx)(i.td,{children:"Supports software stepping"}),(0,t.jsx)(i.td,{children:"Yes"}),(0,t.jsx)(i.td,{children:"No"})]}),(0,t.jsxs)(i.tr,{children:[(0,t.jsx)(i.td,{children:"Simplicity of state machine scripting"}),(0,t.jsx)(i.td,{children:"Simpler, software-like scripting"}),(0,t.jsx)(i.td,{children:"More complex"})]}),(0,t.jsxs)(i.tr,{children:[(0,t.jsx)(i.td,{children:"Can perform stepping fault-injection and signal manipulation"}),(0,t.jsx)(i.td,{children:"Yes"}),(0,t.jsx)(i.td,{children:"No"})]}),(0,t.jsxs)(i.tr,{children:[(0,t.jsx)(i.td,{children:"Can perform active debugging (producing fuzzing signals)"}),(0,t.jsx)(i.td,{children:"Yes"}),(0,t.jsx)(i.td,{children:"No"})]})]})]}),"\n",(0,t.jsx)(i.h1,{id:"limitations",children:"Limitations"}),"\n",(0,t.jsx)(i.p,{children:"Debugging capabilities are limited by the clock frequency of the FPGA used in hwdbg. FPGAs typically operate at much lower clock frequencies than high-speed CPUs, such as a 4 GHz CPU, making it impractical to debug these high-frequency components with hwdbg. This difference in clock speeds means that FPGAs cannot capture or analyze signals that change at such high rates."})]})}function h(e={}){const{wrapper:i}={...(0,s.R)(),...e.components};return i?(0,t.jsx)(i,{...e,children:(0,t.jsx)(l,{...e})}):l(e)}},8453:(e,i,n)=>{n.d(i,{R:()=>a,x:()=>o});var t=n(6540);const s={},r=t.createContext(s);function a(e){const i=t.useContext(r);return t.useMemo((function(){return"function"==typeof e?e(i):{...i,...e}}),[i,e])}function o(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),t.createElement(r.Provider,{value:i},e.children)}}}]);