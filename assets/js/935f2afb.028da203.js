"use strict";(self.webpackChunkhwdbg_website=self.webpackChunkhwdbg_website||[]).push([[8581],{5610:e=>{e.exports=JSON.parse('{"pluginId":"default","version":"current","label":"Next","banner":null,"badge":false,"noIndex":false,"className":"docs-version-current","isLast":true,"docsSidebars":{"tutorialSidebar":[{"type":"link","label":"hwdbg","href":"/docs/","docId":"index","unlisted":false},{"type":"link","label":"Getting Started","href":"/docs/getting-started","docId":"getting-started","unlisted":false},{"type":"link","label":"Frequently Asked Question (FAQs)","href":"/docs/faq","docId":"faq","unlisted":false},{"type":"link","label":"Basic Concepts","href":"/docs/concepts","docId":"concepts","unlisted":false},{"type":"category","label":"Scripting Language","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"Preliminaries","href":"/docs/script/preliminaries","docId":"script/preliminaries","unlisted":false},{"type":"link","label":"Script Execution Stages","href":"/docs/script/stages","docId":"script/stages","unlisted":false},{"type":"category","label":"Hardware Script (hdslang)","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"Keywords","href":"/docs/script/dslang/keywords","docId":"script/dslang/keywords","unlisted":false},{"type":"link","label":"Operators","href":"/docs/script/dslang/operators","docId":"script/dslang/operators","unlisted":false},{"type":"link","label":"Registers & Pseudo-registers","href":"/docs/script/dslang/registers","docId":"script/dslang/registers","unlisted":false},{"type":"link","label":"Number Prefixes","href":"/docs/script/dslang/num-prefix","docId":"script/dslang/num-prefix","unlisted":false},{"type":"link","label":"Comments","href":"/docs/script/dslang/comments","docId":"script/dslang/comments","unlisted":false},{"type":"link","label":"Escape Characters","href":"/docs/script/dslang/escape","docId":"script/dslang/escape","unlisted":false},{"type":"link","label":"Functions","href":"/docs/script/dslang/functions","docId":"script/dslang/functions","unlisted":false},{"type":"link","label":"Assignments","href":"/docs/script/dslang/assignments","docId":"script/dslang/assignments","unlisted":false},{"type":"link","label":"Conditional Statements","href":"/docs/script/dslang/conditional-statements","docId":"script/dslang/conditional-statements","unlisted":false},{"type":"link","label":"Loops","href":"/docs/script/dslang/loops","docId":"script/dslang/loops","unlisted":false},{"type":"link","label":"User-defined Functions","href":"/docs/script/dslang/user-defined-functions","docId":"script/dslang/user-defined-functions","unlisted":false},{"type":"link","label":"Extensions & Arguments","href":"/docs/script/dslang/arguments","docId":"script/dslang/arguments","unlisted":false}],"href":"/docs/script/dslang/"}],"href":"/docs/category/scripting-language"},{"type":"category","label":"Debugging Sensors","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"Ring Oscillator (RO)","href":"/docs/sensors/ring-oscillator","docId":"sensors/ring-oscillator","unlisted":false},{"type":"link","label":"Time-to-Digital Converter (TDC)","href":"/docs/sensors/time-to-digital-converter","docId":"sensors/time-to-digital-converter","unlisted":false},{"type":"link","label":"IDELAYE2/3","href":"/docs/sensors/IDELAYE","docId":"sensors/IDELAYE","unlisted":false},{"type":"link","label":"Voltage Sensor","href":"/docs/sensors/voltage","docId":"sensors/voltage","unlisted":false},{"type":"link","label":"Frequency Sensor","href":"/docs/sensors/frequency","docId":"sensors/frequency","unlisted":false},{"type":"link","label":"Temperature sensor","href":"/docs/sensors/temperature","docId":"sensors/temperature","unlisted":false},{"type":"link","label":"Clock Sensor","href":"/docs/sensors/clock","docId":"sensors/clock","unlisted":false}],"href":"/docs/sensors/"},{"type":"category","label":"Use Cases","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"Hardware Debugging, Reversing & Fuzzing","href":"/docs/use-cases/reversing-and-fuzzing","docId":"use-cases/reversing-and-fuzzing","unlisted":false},{"type":"link","label":"dslang vs. Trigger State Machine (TSM)","href":"/docs/use-cases/comparing-with-tsm","docId":"use-cases/comparing-with-tsm","unlisted":false}],"href":"/docs/category/use-cases"},{"type":"category","label":"Design Internals","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"Debugging Input/Output Pins","href":"/docs/design-internals/chip-in-out","docId":"design-internals/chip-in-out","unlisted":false},{"type":"link","label":"Design Flow","href":"/docs/design-internals/design-flow","docId":"design-internals/design-flow","unlisted":false},{"type":"link","label":"Communication Protocols","href":"/docs/design-internals/communication","docId":"design-internals/communication","unlisted":false},{"type":"category","label":"Modules","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"Sending Module","href":"/docs/design-internals/modules/sending","docId":"design-internals/modules/sending","unlisted":false},{"type":"link","label":"Receiving Module","href":"/docs/design-internals/modules/receiving","docId":"design-internals/modules/receiving","unlisted":false},{"type":"link","label":"The Sender/Receiver Synchronization Module","href":"/docs/design-internals/modules/synchronization","docId":"design-internals/modules/synchronization","unlisted":false},{"type":"link","label":"Interpreting Module","href":"/docs/design-internals/modules/interpreting","docId":"design-internals/modules/interpreting","unlisted":false}],"href":"/docs/category/modules"},{"type":"link","label":"BlockRAM (BRAM) Simulator","href":"/docs/design-internals/bram-simulator","docId":"design-internals/bram-simulator","unlisted":false}],"href":"/docs/design-internals/"}]},"docs":{"concepts":{"id":"concepts","title":"Basic Concepts","description":"This section introduces the key concepts and terminologies that are essential in understanding the development and application of hwdbg.","sidebar":"tutorialSidebar"},"design-internals/bram-simulator":{"id":"design-internals/bram-simulator","title":"BlockRAM (BRAM) Simulator","description":"To test and debug the hwdbg effectively, a BlockRAM simulator module was developed, filled with sample testing data from a file. As the Chisel language does not directly support BlockRAM components, despite its support for SRAM modules, an 8 KB flip-flop module was created to simulate the behavior of BlockRAM. At the moment 8 KB was proved to be enough to support most of the hwdbg tasks. This module features input/output ports similar to those of Xilinx FPGA BlockRAMs, ensuring compatibility and accurate simulation. The delay characteristics of the BlockRAM were also emulated which allows the testing module to initialize the flip-flops with test data sent from the PS to PL.","sidebar":"tutorialSidebar"},"design-internals/chip-in-out":{"id":"design-internals/chip-in-out","title":"Debugging Input/Output Pins","description":"There are five divisions of pins in hwdbg.","sidebar":"tutorialSidebar"},"design-internals/communication":{"id":"design-internals/communication","title":"Communication Protocols","description":"The communication protocol follows a packet-based design between sender and receiver. These packets contain special mandatory headers to check for the integrity of the packet and prevent communication errors as well as specifying which component in the debugger/debuggee is responsible for handling the receiving packet and the corresponding action. To achieve this, a communication protocol is designed, similar to the one used in HyperDbg, enabling data exchange through shared memory.","sidebar":"tutorialSidebar"},"design-internals/design-flow":{"id":"design-internals/design-flow","title":"Design Flow","description":"Figure below shows the flowchart of hwdbg from design to the bitstream generation for FPGA implementation. It starts with HDL code, which can be written in Verilog (.SV) or SystemVerilog (.V). This code is then synthesized by Xilinx Vivado into an RTL netlist (.rtl).","sidebar":"tutorialSidebar"},"design-internals/index":{"id":"design-internals/index","title":"Design Internals","description":"Here, the design consideration for different components of hwdbg is discussed.","sidebar":"tutorialSidebar"},"design-internals/modules/interpreting":{"id":"design-internals/modules/interpreting","title":"Interpreting Module","description":"Once valid data is received from either the PS, the interpreting module takes charge of analyzing the incoming packets. It decodes the received data, interprets its meaning or purpose, and triggers any necessary actions or responses within the hwdbg. This module involves parsing incoming commands, executing debugging operations, or generating responses to be sent back to the PS.","sidebar":"tutorialSidebar"},"design-internals/modules/receiving":{"id":"design-internals/modules/receiving","title":"Receiving Module","description":"The receiving module is responsible for capturing incoming data from PS and passing it to the hwdbg for further processing. It monitors the designated port (PS to PL shared line) for incoming data packets, retrieves them, checks for validity, and forwards them to the appropriate components within the debugger for interpretation or storage.","sidebar":"tutorialSidebar"},"design-internals/modules/sending":{"id":"design-internals/modules/sending","title":"Sending Module","description":"This module is responsible for transmitting data from the hardware debugger (hwdbg) or the Programmable Logic (PL) to the Processor System (PS). It handles the process of packaging the data into packets suitable for transmission and sending them out through the designated port. Additionally, it adds different headers and manages any necessary handshaking protocols, and adjusts mandatory fields to ensure successful data transmission.","sidebar":"tutorialSidebar"},"design-internals/modules/synchronization":{"id":"design-internals/modules/synchronization","title":"The Sender/Receiver Synchronization Module","description":"This module plays a crucial role in ensuring that the sending and receiving operations within the hwdbg occur without conflicts. It manages the timing and coordination between the sending and receiving modules, preventing them from attempting to access the shared resources simultaneously. Other than that, based on the fact that Xilinx FPGAs are manufactured with BRAMs with two ports, one port is shared with PS, and the other one is shared with PL, thus, no two modules (in PL) can use a single port simultaneously. By enforcing synchronization, this module helps prevent data corruption between multiple modules (in PL) and ensures the integrity of communications between the debugger and the PL/PS.","sidebar":"tutorialSidebar"},"faq":{"id":"faq","title":"Frequently Asked Question (FAQs)","description":"To be completed!","sidebar":"tutorialSidebar"},"getting-started":{"id":"getting-started","title":"Getting Started","description":"Here\'s a detailed guide on how to get started with the hwdbg debugger.","sidebar":"tutorialSidebar"},"index":{"id":"index","title":"hwdbg","description":"The hwdbg debugger chip generator is a gate-level debugging tool designed to make configurable and synthesizable hardware debuggers for white-box and black-box chip fuzzing, testing, and reverse engineering. The primary goal of hwdbg is to provide control over hardware, enabling monitoring and modification of signals down to the granular level of a single clock cycle. It is written in Chisel and Verilog.","sidebar":"tutorialSidebar"},"script/dslang/arguments":{"id":"script/dslang/arguments","title":"Extensions & Arguments","description":"Batch scripts are essential parts of hardware debugging and the script engine and it is mainly used to automate debugging tasks.","sidebar":"tutorialSidebar"},"script/dslang/assignments":{"id":"script/dslang/assignments","title":"Assignments","description":"By using a simple lvalue register assignment, a hardware engineer is able to change the value of each pin (register).","sidebar":"tutorialSidebar"},"script/dslang/comments":{"id":"script/dslang/comments","title":"Comments","description":"hwdbg\'s comments are like C comments. A comment starts with a slash asterisk / and ends with an asterisk slash / and can be anywhere in your program. Comments can span several lines within your C program.","sidebar":"tutorialSidebar"},"script/dslang/conditional-statements":{"id":"script/dslang/conditional-statements","title":"Conditional Statements","description":"Conditional statements are used to perform different actions based on different conditions.","sidebar":"tutorialSidebar"},"script/dslang/escape":{"id":"script/dslang/escape","title":"Escape Characters","description":"Special characters such as \\\\n and \\\\t, are used to represent special characters like newline and tab within strings. Additionally, hexadecimal representations between strings, like \\\\x41\\\\x42\\\\x43, enable the inclusion of specific byte values in a character sequence.","sidebar":"tutorialSidebar"},"script/dslang/functions":{"id":"script/dslang/functions","title":"Functions","description":"hwdbg supports multiple pre-defined functions. In the first release, the functions shown in the table below are supported. Note that, to make the debugger smaller (utilizing fewer resources), hardware engineers can configure it to remove the support for these functions.","sidebar":"tutorialSidebar"},"script/dslang/index":{"id":"script/dslang/index","title":"Hardware Script (hdslang)","description":"hwdbg use HyperDbg scripting (dslang) syntax which is a MASM-like syntax to evaluate script expressions. The dslang scripts are case-sensitive and hwdbg-specific keywords and functions start with hw\\\\_ prefix.","sidebar":"tutorialSidebar"},"script/dslang/keywords":{"id":"script/dslang/keywords","title":"Keywords","description":"The keywords shown below are valid in hwdbg scripts.","sidebar":"tutorialSidebar"},"script/dslang/loops":{"id":"script/dslang/loops","title":"Loops","description":"At the moment, hardware debugging does not support loops. The absence of loop support stems from the fact that executing loops may require additional clock cycles (stages) to iterate through the scripts. However, this is not feasible because hwdbg directly transfers incoming signals (after the stage delay) to the output without allowing for looping. In certain cases, one can achieve loop behavior by explicitly utilizing consecutive statements.","sidebar":"tutorialSidebar"},"script/dslang/num-prefix":{"id":"script/dslang/num-prefix","title":"Number Prefixes","description":"By default, hwdbg interprets the numbers as hex (base 16). If you want to specify other forms of a number, you should use MASM prefixes. In all MASM expressions, numeric values are interpreted as numbers in the current radix (16, 10, or 8). You can override the default radix by specifying the 0x prefix (hexadecimal), the 0n prefix (decimal), the 0t prefix (octal), or the 0y prefix (binary).","sidebar":"tutorialSidebar"},"script/dslang/operators":{"id":"script/dslang/operators","title":"Operators","description":"Multiple operators are supported in hwdbg. Note that operators like multiplication, division, and modulus are disabled by default since these operators negatively influence the critical path and decrease the overall supported clock speed. The user might enable these operators by manually configuring the chip generator.","sidebar":"tutorialSidebar"},"script/dslang/registers":{"id":"script/dslang/registers","title":"Registers & Pseudo-registers","description":"Here are the current registers and pseudo-registers supported by the script engine (See Table below). Note that registers (pins) start with \'@\' and pseudo-registers (ports) start with \'\\\\$\'.","sidebar":"tutorialSidebar"},"script/dslang/user-defined-functions":{"id":"script/dslang/user-defined-functions","title":"User-defined Functions","description":"dslang functions are defined using the same syntax as the C programming language.","sidebar":"tutorialSidebar"},"script/preliminaries":{"id":"script/preliminaries","title":"Preliminaries","description":"This section discusses the debugger script language implemented in hwdbg.","sidebar":"tutorialSidebar"},"script/stages":{"id":"script/stages","title":"Script Execution Stages","description":"To enable on-the-fly script evaluation, script execution is divided into several stages. Each stage includes multiple flip-flops, with the number of flip-flops equal to the number of input pins. Additionally, each stage contains a small buffer (which could be either SRAM or flip-flop) that holds the specific operation to be performed in that stage.","sidebar":"tutorialSidebar"},"sensors/clock":{"id":"sensors/clock","title":"Clock Sensor","description":"Clock sensors monitor and verify clock signals within a hardware system. Accurate clock signals are critical for timing and synchronization, and clock sensors help ensure that these signals remain within specified tolerances.","sidebar":"tutorialSidebar"},"sensors/frequency":{"id":"sensors/frequency","title":"Frequency Sensor","description":"Frequency sensors measure the operating frequency of hardware components, which ensures that they function within specified parameters. Accurate frequency measurement is essential for verifying clock signals and maintaining synchronization across the system.","sidebar":"tutorialSidebar"},"sensors/IDELAYE":{"id":"sensors/IDELAYE","title":"IDELAYE2/3","description":"IDELAYE3, or Input Delay Element, is a programmable delay line used to manage signal timing and synchronization in digital circuits. It allows precise adjustment of the delay applied to incoming signals, facilitating accurate timing alignment and data capture.","sidebar":"tutorialSidebar"},"sensors/index":{"id":"sensors/index","title":"Debugging Sensors","description":"One of the main components of hwdbg is debugging sensors. This section discusses the debugging sensors implemented in the debugger.","sidebar":"tutorialSidebar"},"sensors/ring-oscillator":{"id":"sensors/ring-oscillator","title":"Ring Oscillator (RO)","description":"A ring oscillator is a type of electronic oscillator consisting of an odd number of inverters connected in a loop. It generates a periodic oscillating signal by continuously switching states, creating a sequence of voltage pulses. The frequency of this oscillation is influenced by factors such as voltage, temperature, and the manufacturing process, making ring oscillators useful for detecting variations in these parameters. The following figure illustrates a ring oscillator with an odd number of stages.","sidebar":"tutorialSidebar"},"sensors/temperature":{"id":"sensors/temperature","title":"Temperature sensor","description":"As their name implies, temperature sensors provide details about the thermal state of hardware components, and thermal stability.","sidebar":"tutorialSidebar"},"sensors/time-to-digital-converter":{"id":"sensors/time-to-digital-converter","title":"Time-to-Digital Converter (TDC)","description":"A Time-to-Digital Converter (TDC) measures time intervals with high precision by converting the time difference between two events into a digital value.","sidebar":"tutorialSidebar"},"sensors/voltage":{"id":"sensors/voltage","title":"Voltage Sensor","description":"Voltage sensors monitor the voltage levels within a hardware system, providing data for maintaining optimal operation and preventing damage from overvoltage or undervoltage conditions.","sidebar":"tutorialSidebar"},"use-cases/comparing-with-tsm":{"id":"use-cases/comparing-with-tsm","title":"dslang vs. Trigger State Machine (TSM)","description":"In this section, the impact of the proposed hardware debugger is discussed and the evaluation result between similar tools (Xilinx ILA) is elaborated.","sidebar":"tutorialSidebar"},"use-cases/reversing-and-fuzzing":{"id":"use-cases/reversing-and-fuzzing","title":"Hardware Debugging, Reversing & Fuzzing","description":"This section discusses the chip debugging terms and reverse engineering in hwdbg.","sidebar":"tutorialSidebar"}}}')}}]);