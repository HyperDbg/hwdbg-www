"use strict";(self.webpackChunkhwdbg_website=self.webpackChunkhwdbg_website||[]).push([[2871],{8608:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>c,contentTitle:()=>o,default:()=>h,frontMatter:()=>a,metadata:()=>r,toc:()=>l});var t=i(4848),s=i(8453);const a={},o="Hardware Debugging, Reversing & Fuzzing",r={id:"usecases",title:"Hardware Debugging, Reversing & Fuzzing",description:"This section discusses the chip debugging terms and reverse engineering in hwdbg.",source:"@site/docs/usecases.md",sourceDirName:".",slug:"/usecases",permalink:"/docs/usecases",draft:!1,unlisted:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/usecases.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Evaluation",permalink:"/docs/tests"}},c={},l=[{value:"Logic Analyzer (Reading/Writing Memory)",id:"logic-analyzer-readingwriting-memory",level:2},{value:"Signal Inspection and Modification (Inspecting/Modifying Registers Values)",id:"signal-inspection-and-modification-inspectingmodifying-registers-values",level:2},{value:"Emulation of Instruction Stepping by Controlling Clock Signal (Stepping Through Instructions)",id:"emulation-of-instruction-stepping-by-controlling-clock-signal-stepping-through-instructions",level:2},{value:"Cutting The Signals Based on Conditions (Putting Breakpoints and Pausing The Debuggee)",id:"cutting-the-signals-based-on-conditions-putting-breakpoints-and-pausing-the-debuggee",level:2},{value:"Anomalies In Expected Functionalities",id:"anomalies-in-expected-functionalities",level:2},{value:"Anomalies Based On Sensors Indications",id:"anomalies-based-on-sensors-indications",level:2},{value:"Cut The Signal",id:"cut-the-signal",level:2},{value:"Changing Clock Domain Using PWM",id:"changing-clock-domain-using-pwm",level:2}];function d(e){const n={code:"code",em:"em",h1:"h1",h2:"h2",img:"img",li:"li",p:"p",ul:"ul",...(0,s.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.h1,{id:"hardware-debugging-reversing--fuzzing",children:"Hardware Debugging, Reversing & Fuzzing"}),"\n",(0,t.jsx)(n.p,{children:"This section discusses the chip debugging terms and reverse engineering in hwdbg."}),"\n",(0,t.jsx)(n.h1,{id:"software-debugging-components",children:"Software Debugging Components"}),"\n",(0,t.jsx)(n.p,{children:"In software debugging, a native debugger should come with at least 4 main components:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Reading/writing memory"}),"\n",(0,t.jsx)(n.li,{children:"Inspecting/modifying registers values"}),"\n",(0,t.jsx)(n.li,{children:"Stepping through instructions"}),"\n",(0,t.jsx)(n.li,{children:"Putting breakpoints and pausing the debuggee"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"Now, each of the above-mentioned components is discussed in detail based on their equivalent actions in hardware systems."}),"\n",(0,t.jsx)(n.h2,{id:"logic-analyzer-readingwriting-memory",children:"Logic Analyzer (Reading/Writing Memory)"}),"\n",(0,t.jsx)(n.p,{children:"hwdbg can be used as a logic analyzer. This debugger is able to use a configurable number of BlockRAMs to store (write) the value of signals in different timing stages. These signals can then be retrieved (read) by the PS and further illustrated in the form of digital waves."}),"\n",(0,t.jsx)(n.h2,{id:"signal-inspection-and-modification-inspectingmodifying-registers-values",children:"Signal Inspection and Modification (Inspecting/Modifying Registers Values)"}),"\n",(0,t.jsx)(n.p,{children:"The equivalent of registers in the hwdbg are signals (wires). These input signals can be inspected and further modified using custom scripts."}),"\n",(0,t.jsx)(n.h2,{id:"emulation-of-instruction-stepping-by-controlling-clock-signal-stepping-through-instructions",children:"Emulation of Instruction Stepping by Controlling Clock Signal (Stepping Through Instructions)"}),"\n",(0,t.jsx)(n.p,{children:"If the clock signal is also available to hwdbg, it is possible to control the clock signal passed to the module (IP core) and emulate a behavior similar to the instructions stepping in software debugging. For example, the hardware engineer can pause the signals passed to the chip (including the clock signal) and inspect the values. In the next step, he/she is able to inspect the signal values and modify the pin/port values if needed. Once the inspection/modification is done, one step or one clock rising-edge can be provided to the debuggee chip causing it to further execute the next stage and then avoid producing the next clock cycle."}),"\n",(0,t.jsx)(n.p,{children:"These manipulation (stopping/running) clock signals are considered as the similar approach in software debugging as for stepping through instruction. Note that, it is not possible to step through the signals in chips where the clock signal is internally produced. This stepping mechanism only applies to those chips that are using external (debugger-controlled) clock signals."}),"\n",(0,t.jsx)(n.h2,{id:"cutting-the-signals-based-on-conditions-putting-breakpoints-and-pausing-the-debuggee",children:"Cutting The Signals Based on Conditions (Putting Breakpoints and Pausing The Debuggee)"}),"\n",(0,t.jsxs)(n.p,{children:["As the emulation of putting breakpoints in software debugging, hwdbg comes with the ability to evaluate conditions and trigger events when the conditions are met. The script engine evaluation core (described in Chapter ",(0,t.jsx)(n.code,{children:"\\ref{Chapter:Debugger_Script}"}),") is responsible for comparing and evaluating conditions (using ",(0,t.jsx)(n.code,{children:"if"})," statements) and when the conditions are satisfied, different functions can be used to further pause the execution (pause passing the clock signal to the chip) or produce user configured input instead of the real signal values."]}),"\n",(0,t.jsx)(n.p,{children:"Using these components and facilities, a hardware engineer or a security researcher can investigate chips and IP cores and analyze them effectively."}),"\n",(0,t.jsx)(n.h1,{id:"anomaly-definition",children:"Anomaly Definition"}),"\n",(0,t.jsxs)(n.p,{children:["When it comes to testing and fuzzing chips, it is important to have a common definition of ",(0,t.jsx)(n.em,{children:"anomaly"}),", as fuzzing involves searching for anomalies in software or hardware. An anomaly is the occurrence of an unexpected state that the designer did not anticipate. Once an anomaly is detected, hwdbg can determine the appropriate subsequent action. Previously, researchers",(0,t.jsx)(n.code,{children:"~\\cite{trippel2022fuzzing}"})," introduced a definition of anomalies that can occur within chips for white-box (RTL source code is available) fuzzing. Since hwdbg mainly operates on black-box (closed source) chips, the same anomaly concepts could not be used, hence we have categorized hardware anomalies into two subsections, each described below."]}),"\n",(0,t.jsx)(n.h2,{id:"anomalies-in-expected-functionalities",children:"Anomalies In Expected Functionalities"}),"\n",(0,t.jsx)(n.p,{children:"These anomalies occur when the device malfunctions in response to specific inputs. For instance, the chip or IP core may fail to compute the correct output. These anomalies can be detected when the user knows the target chip well enough to emulate or predict the correct output based on the given inputs, using software that mimics the chip's behavior."}),"\n",(0,t.jsx)(n.p,{children:"% ## Anomalies Based On Output Signal State"}),"\n",(0,t.jsx)(n.p,{children:"% These anomalies are detected based on the state of output signals. For example, detection mechanisms can identify if a signal goes to an 'X' (unknown), 'U' (uninitialized), or 'Z' (high-impedance) state, which could indicate a fault or unexpected behavior in the chip."}),"\n",(0,t.jsx)(n.h2,{id:"anomalies-based-on-sensors-indications",children:"Anomalies Based On Sensors Indications"}),"\n",(0,t.jsx)(n.p,{children:"Sensors can detect possible anomalies or changes in chip coverage due to modifications in the chip's state. Abnormal changes in sensors can indicate an anomaly. For example, a significant state change in a ring oscillator (RO) within a module, even if not reflected in the output, could signal an internal anomaly in the chip."}),"\n",(0,t.jsx)(n.h1,{id:"automated-fuzzing",children:"Automated Fuzzing"}),"\n",(0,t.jsx)(n.p,{children:"Automated fuzzing involves the automated generation and injection of a large volume of random or semi-random inputs into a system to identify vulnerabilities, unexpected behaviors, or crashes. In the context of hardware debugging, automated fuzzing is used to systematically and thoroughly test chips or IP cores to uncover hidden bugs and security flaws. Tools for automated fuzzing generate diverse test cases that can trigger rare corner cases or faults. By continuously running these tests and monitoring the system's response, developers and security researchers can identify and find weaknesses in the design. hwdbg can leverage automated fuzzing to enhance the reliability and security of black-box chips by finding and addressing issues before mass production."}),"\n",(0,t.jsx)(n.h1,{id:"fault-injection",children:"Fault Injection"}),"\n",(0,t.jsx)(n.p,{children:"Fault injection is a technique used to test the robustness and reliability of hardware by injecting faults into the system. This method helps in understanding how a system behaves under error conditions and in validating the effectiveness of fault tolerance mechanisms. There are various methods of fault injection, including physical, logical, and software-based techniques. hwdbg can use fault injection to simulate a wide range of fault conditions, thereby ensuring that the system can handle real-world scenarios and recover gracefully from faults. The below figure illustrates the basic components of an error injection environment."}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.img,{alt:"Basic Components of an Error Injection Environment. \\citeruano2021fault",src:i(1664).A+"",width:"977",height:"451"})}),"\n",(0,t.jsx)(n.h2,{id:"cut-the-signal",children:"Cut The Signal"}),"\n",(0,t.jsx)(n.p,{children:"Cutting the signal involves intentionally breaking the continuity of a signal path (e.g., the clock signal) within the hardware. This can be used to simulate open-circuit faults or to test the system's response to sudden loss of input. By inserting a fault that temporarily or permanently disconnects a signal line, hardware engineers and security researchers can observe how the hardware reacts, whether it can detect the disconnection, and whether it can continue to operate correctly or not. This method is particularly useful in testing the robustness of communication links and critical signal paths in the design."}),"\n",(0,t.jsx)(n.h2,{id:"changing-clock-domain-using-pwm",children:"Changing Clock Domain Using PWM"}),"\n",(0,t.jsx)(n.p,{children:"Changing the clock domain using Pulse Width Modulation (PWM) involves altering the clock signal supplied to a part of the circuit. PWM can vary the duty cycle of the clock signal, effectively modifying the clock frequency and simulating various timing scenarios. This technique can be used to test the behavior of the hardware under different clock conditions, such as overclocking, underclocking, and clock glitches. By using PWM to change the clock domain, hwdbg can test the timing resilience of the system, ensure that it operates correctly across a range of clock frequencies, and identify any timing-related faults or vulnerabilities. The following figure demonstrates PWM signals with 50%, 10%, 30%, and 70% duty cycles."}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.img,{alt:"PWM Signals with Different Duty Cycles.",src:i(6605).A+"",width:"1485",height:"1284"})})]})}function h(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},1664:(e,n,i)=>{i.d(n,{A:()=>t});const t=i.p+"assets/images/basic-fault-injection-e7164b8320aa834555387f1094745386.jpg"},6605:(e,n,i)=>{i.d(n,{A:()=>t});const t=i.p+"assets/images/pwm-b53b09ce59966749bb6634792eed2e74.jpg"},8453:(e,n,i)=>{i.d(n,{R:()=>o,x:()=>r});var t=i(6540);const s={},a=t.createContext(s);function o(e){const n=t.useContext(a);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),t.createElement(a.Provider,{value:n},e.children)}}}]);