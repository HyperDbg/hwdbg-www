"use strict";(self.webpackChunkhwdbg_website=self.webpackChunkhwdbg_website||[]).push([[8513],{8437:(e,t,s)=>{s.r(t),s.d(t,{assets:()=>c,contentTitle:()=>a,default:()=>p,frontMatter:()=>o,metadata:()=>r,toc:()=>l});var i=s(4848),n=s(8453);const o={sidebar_position:2},a="Script Execution Stages",r={id:"script/stages",title:"Script Execution Stages",description:"To enable on-the-fly script evaluation, script execution is divided into several stages. Each stage includes multiple flip-flops, with the number of flip-flops equal to the number of input pins. Additionally, each stage contains a small buffer (which could be either SRAM or flip-flop) that holds the specific operation to be performed in that stage.",source:"@site/docs/script/stages.md",sourceDirName:"script",slug:"/script/stages",permalink:"/docs/script/stages",draft:!1,unlisted:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/script/stages.md",tags:[],version:"current",sidebarPosition:2,frontMatter:{sidebar_position:2},sidebar:"tutorialSidebar",previous:{title:"Preliminaries",permalink:"/docs/script/preliminaries"},next:{title:"Hardware Script (hdslang)",permalink:"/docs/script/dslang/"}},c={},l=[];function h(e){const t={code:"code",em:"em",h1:"h1",img:"img",p:"p",pre:"pre",...(0,n.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.h1,{id:"script-execution-stages",children:"Script Execution Stages"}),"\n",(0,i.jsx)(t.p,{children:"To enable on-the-fly script evaluation, script execution is divided into several stages. Each stage includes multiple flip-flops, with the number of flip-flops equal to the number of input pins. Additionally, each stage contains a small buffer (which could be either SRAM or flip-flop) that holds the specific operation to be performed in that stage."}),"\n",(0,i.jsxs)(t.p,{children:["After the debugger transmits the script buffer to the debuggee (PL), hwdbg configures these small buffers with the details of the actions (operators and values) required for each stage. The evaluation module then advances the registers to the next stage with each clock cycle. At each stage, the input flip-flops are evaluated according to the script, and the values of the pins may be modified based on the script's instructions. Once the execution completes all stages, the final stage passes the flip-flops to the ",(0,i.jsx)(t.em,{children:"Output Policy Stage"})," before sending them to the output pins. The following figure depicts a 4-stage script evaluation engine. Note that the number of stages is configurable by the hardware engineer. For example, a debugger equipped with more script execution engines can run more operations within a single script, although this results in a larger hardware area (utilized resources in FPGAs)."]}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.img,{alt:"4-Stage Script Evaluation and Execution Engine.",src:s(8615).A+"",width:"3222",height:"1390"})}),"\n",(0,i.jsx)(t.p,{children:"As mentioned earlier, each execution engine comes with a small buffer (SRAM or Flip-Flop) that contains local operations to that specific stage. This buffer conducts the script evaluation engine on how to behave with the signal at the corresponding stage. The following C structure shows how these local buffers are formed in hwdbg."}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:"typedef struct SYMBOL {\r\n    long long unsigned Type;\r\n    long long unsigned Len;\r\n    long long unsigned VariableType;\r\n    long long unsigned Value;\r\n } SYMBOL, * PSYMBOL;\n"})}),"\n",(0,i.jsx)(t.h1,{id:"output-policy-stage",children:"Output Policy Stage"}),"\n",(0,i.jsxs)(t.p,{children:["The last stage before sending flop-flops (possibly modified input) is the ",(0,i.jsx)(t.em,{children:"Output Policy Stage"}),". As its name implies this stage decides how outputs should be sent over the wires (pins). For example, some functions are designed to block output (send zero) which in reality these functions change the policy of this stage and influence the output signal. Other than that, functionalities like stepping through the signals and pausing the signals are implemented by employing this mechanism. The following figure depicts how this mechanism is connected to the script execution stages."]}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.img,{alt:"Script Evaluation Stages and Output Policy.",src:s(3581).A+"",width:"1027",height:"1044"})})]})}function p(e={}){const{wrapper:t}={...(0,n.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(h,{...e})}):h(e)}},3581:(e,t,s)=>{s.d(t,{A:()=>i});const i=s.p+"assets/images/exec-stages-and-output-policy-bc9e0a4d719b49061f5f0a88b8598d39.jpg"},8615:(e,t,s)=>{s.d(t,{A:()=>i});const i=s.p+"assets/images/exec-stages-18c89f2fe32bc06618628fb150a1e1fe.jpg"},8453:(e,t,s)=>{s.d(t,{R:()=>a,x:()=>r});var i=s(6540);const n={},o=i.createContext(n);function a(e){const t=i.useContext(o);return i.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(n):e.components||n:a(e.components),i.createElement(o.Provider,{value:t},e.children)}}}]);