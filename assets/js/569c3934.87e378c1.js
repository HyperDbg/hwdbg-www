"use strict";(self.webpackChunkhwdbg_website=self.webpackChunkhwdbg_website||[]).push([[9583],{7444:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>o,default:()=>l,frontMatter:()=>r,metadata:()=>a,toc:()=>c});var i=t(4848),s=t(8453);const r={sidebar_position:3},o="The Sender/Receiver Synchronization Module",a={id:"design-internals/modules/synchronization",title:"The Sender/Receiver Synchronization Module",description:"This module plays a crucial role in ensuring that the sending and receiving operations within the hwdbg occur without conflicts. It manages the timing and coordination between the sending and receiving modules, preventing them from attempting to access the shared resources simultaneously. Other than that, based on the fact that Xilinx FPGAs are manufactured with BRAMs with two ports, one port is shared with PS, and the other one is shared with PL, thus, no two modules (in PL) can use a single port simultaneously. By enforcing synchronization, this module helps prevent data corruption between multiple modules (in PL) and ensures the integrity of communications between the debugger and the PL/PS.",source:"@site/docs/design-internals/modules/synchronization.md",sourceDirName:"design-internals/modules",slug:"/design-internals/modules/synchronization",permalink:"/docs/design-internals/modules/synchronization",draft:!1,unlisted:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/design-internals/modules/synchronization.md",tags:[],version:"current",sidebarPosition:3,frontMatter:{sidebar_position:3},sidebar:"tutorialSidebar",previous:{title:"Receiving Module",permalink:"/docs/design-internals/modules/receiving"},next:{title:"Interpreting Module",permalink:"/docs/design-internals/modules/interpreting"}},d={},c=[];function h(e){const n={code:"code",h1:"h1",img:"img",p:"p",...(0,s.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.h1,{id:"the-senderreceiver-synchronization-module",children:"The Sender/Receiver Synchronization Module"}),"\n",(0,i.jsx)(n.p,{children:"This module plays a crucial role in ensuring that the sending and receiving operations within the hwdbg occur without conflicts. It manages the timing and coordination between the sending and receiving modules, preventing them from attempting to access the shared resources simultaneously. Other than that, based on the fact that Xilinx FPGAs are manufactured with BRAMs with two ports, one port is shared with PS, and the other one is shared with PL, thus, no two modules (in PL) can use a single port simultaneously. By enforcing synchronization, this module helps prevent data corruption between multiple modules (in PL) and ensures the integrity of communications between the debugger and the PL/PS."}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{alt:"The FSM of How Sender/Receiver Synchronization Module Works.",src:t(3224).A+"",width:"2425",height:"1533"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{alt:"The Wave Demonstration of How Sender/Receiver Synchronization Module Works.",src:t(9339).A+"",width:"2875",height:"656"})}),"\n",(0,i.jsxs)(n.p,{children:["The diagram illustrates the Moore FSM and the figure is the waveform of the synchronizer module in the hwdbg hardware debugger, responsible for coordinating the sending and receiving of data. The FSM begins in the ",(0,i.jsx)(n.code,{children:"sIdle"})," state, where all control signals (",(0,i.jsx)(n.code,{children:"wrEna"}),", ",(0,i.jsx)(n.code,{children:"rdWrAddr"}),", ",(0,i.jsx)(n.code,{children:"wrData"}),", ",(0,i.jsx)(n.code,{children:"rdData"}),") are initialized to zero, awaiting a trigger to commence data operations. When the ",(0,i.jsx)(n.code,{children:"pllInSignal"})," is asserted (",(0,i.jsx)(n.code,{children:"pllInSignal = 1"}),"), the FSM transitions to the ",(0,i.jsx)(n.code,{children:"sReceiver"})," state, where it performs data reading tasks. In this state, the address for reading is set (",(0,i.jsx)(n.code,{children:"rdWrAddr = requested addr"}),"), and the data to be read is managed. The module remains in ",(0,i.jsx)(n.code,{children:"sReceiver"})," until the ",(0,i.jsx)(n.code,{children:"finishedReceivingBuffer"})," signal is set, indicating that the data reception process is complete."]}),"\n",(0,i.jsxs)(n.p,{children:["Following the reception, the FSM moves back to the ",(0,i.jsx)(n.code,{children:"sIdle"})," state until conditions for sending data are met (",(0,i.jsx)(n.code,{children:"beginSendingData = 1"})," and ",(0,i.jsx)(n.code,{children:"pllInSignal = 0"}),"). Once these conditions are satisfied, the FSM transitions to the ",(0,i.jsx)(n.code,{children:"sSender"})," state. In ",(0,i.jsx)(n.code,{children:"sSender"}),", the module is configured to enable writing (",(0,i.jsx)(n.code,{children:"wrEna = sender value"}),"), set the address for writing (",(0,i.jsx)(n.code,{children:"rdWrAddr = requested addr"}),"), and prepare the data to be written (",(0,i.jsx)(n.code,{children:"wrData = Data to Write"}),"). The FSM remains in this state until the ",(0,i.jsx)(n.code,{children:"finishedSendingBuffer"})," signal is asserted, which marks the completion of the data transmission. Finally, the FSM returns to the ",(0,i.jsx)(n.code,{children:"sIdle"})," state, ready for the next cycle of operations. This synchronized process ensures efficient and orderly data handling, maintaining the integrity and reliability of data transactions within the hardware debugger. Note that in hwdbg, receiving command precedes sending data."]})]})}function l(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(h,{...e})}):h(e)}},3224:(e,n,t)=>{t.d(n,{A:()=>i});const i=t.p+"assets/images/send-receive-data-synchronizer-fsm-165fd47925bf412a6fea9f205eb7e52e.jpg"},9339:(e,n,t)=>{t.d(n,{A:()=>i});const i=t.p+"assets/images/wavedrom-synch-module-4978b53102338641631f0d25d814c0fd.jpg"},8453:(e,n,t)=>{t.d(n,{R:()=>o,x:()=>a});var i=t(6540);const s={},r=i.createContext(s);function o(e){const n=i.useContext(r);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),i.createElement(r.Provider,{value:n},e.children)}}}]);