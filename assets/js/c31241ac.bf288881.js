"use strict";(self.webpackChunkhwdbg_website=self.webpackChunkhwdbg_website||[]).push([[4901],{1958:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>o,default:()=>l,frontMatter:()=>s,metadata:()=>d,toc:()=>a});var i=t(4848),r=t(8453);const s={sidebar_position:4},o="Communication Protocols",d={id:"design-internals/communication",title:"Communication Protocols",description:"The communication protocol follows a packet-based design between sender and receiver. These packets contain special mandatory headers to check for the integrity of the packet and prevent communication errors as well as specifying which component in the debugger/debuggee is responsible for handling the receiving packet and the corresponding action. To achieve this, a communication protocol is designed, similar to the one used in HyperDbg, enabling data exchange through shared memory.",source:"@site/docs/design-internals/communication.md",sourceDirName:"design-internals",slug:"/design-internals/communication",permalink:"/docs/design-internals/communication",draft:!1,unlisted:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/design-internals/communication.md",tags:[],version:"current",sidebarPosition:4,frontMatter:{sidebar_position:4},sidebar:"tutorialSidebar",previous:{title:"Design Flow",permalink:"/docs/design-internals/design-flow"},next:{title:"Modules",permalink:"/docs/category/modules"}},c={},a=[];function h(e){const n={code:"code",h1:"h1",img:"img",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.h1,{id:"communication-protocols",children:"Communication Protocols"}),"\n",(0,i.jsxs)(n.p,{children:["The communication protocol follows a packet-based design between sender and receiver. These packets contain special mandatory headers to check for the integrity of the packet and prevent communication errors as well as specifying which component in the debugger/debuggee is responsible for handling the receiving packet and the corresponding action. To achieve this, a communication protocol is designed, similar to the one used in ",(0,i.jsx)(n.strong,{children:"HyperDbg"}),", enabling data exchange through shared memory."]}),"\n",(0,i.jsx)(n.p,{children:"For the communication between PL and PS, the following structure is used."}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{alt:"The Format of Action Request Packets from PS &lt;&gt; PL Communication.",src:t(6377).A+"",width:"962",height:"221"})}),"\n",(0,i.jsxs)(n.p,{children:["This design uses four mandatory fields. The first is the ",(0,i.jsx)(n.code,{children:"checksum"})," of the incoming/outgoing packet primarily used for checking whether the packet is modified communication problems. The second field is the ",(0,i.jsx)(n.code,{children:"indicator"})," of the packet which is used to identify that the packet is related to a HyperDbg-compatible interpreter. The following table shows an example of a valid indicator."]}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:(0,i.jsx)(n.strong,{children:"Constant Name"})}),(0,i.jsx)(n.th,{children:(0,i.jsx)(n.strong,{children:"Value"})})]})}),(0,i.jsx)(n.tbody,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"INDICATOR_OF_HYPERDBG_PACKET"}),(0,i.jsx)(n.td,{children:"0x4859504552444247"})]})})]}),"\n",(0,i.jsxs)(n.p,{children:["The third field is ",(0,i.jsx)(n.code,{children:"TypeOfThePacket"}),". Two exclusive packet types are owned by hwdbg for sending data from debugger (PS) to debugged (PL) and from debuggee (PL) to debugger (PS)."]}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:(0,i.jsx)(n.strong,{children:"Packet Type"})}),(0,i.jsx)(n.th,{children:(0,i.jsx)(n.strong,{children:"Description"})})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"DEBUGGER_TO_DEBUGGEE_EXECUTE_ON_VMX_ROOT"}),(0,i.jsx)(n.td,{children:"Debugger to debuggee (VMX-root)"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"DEBUGGER_TO_DEBUGGEE_EXECUTE_ON_USER_MODE"}),(0,i.jsx)(n.td,{children:"Debugger to debuggee (user-mode)"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"DEBUGGEE_TO_DEBUGGER"}),(0,i.jsx)(n.td,{children:"Debuggee to debugger (user/kernel & VMX-root)"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"DEBUGGER_TO_DEBUGGEE_HARDWARE_LEVEL"}),(0,i.jsx)(n.td,{children:"Debugger to debuggee (hardware), used in hwdbg"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"DEBUGGEE_TO_DEBUGGER_HARDWARE_LEVEL"}),(0,i.jsx)(n.td,{children:"Debuggee to debugger (hardware), used in hwdbg"})]})]})]}),"\n",(0,i.jsxs)(n.p,{children:["The communication structure is synchronized between hwdbg (written in Scala) and ",(0,i.jsx)(n.strong,{children:"HyperDbg"})," (written in C) and it is demonstrated as follows:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"/**\r\n * @brief The structure of remote packets in HyperDbg\r\n *\r\n */\r\ntypedef struct _DEBUGGER_REMOTE_PACKET\r\n{\r\n    BYTE                                    Checksum;\r\n    UINT64                                  Indicator; /* Shows the type of the packet */\r\n    DEBUGGER_REMOTE_PACKET_TYPE             TypeOfThePacket;\r\n    DEBUGGER_REMOTE_PACKET_REQUESTED_ACTION RequestedActionOfThePacket;\r\n} DEBUGGER_REMOTE_PACKET, *PDEBUGGER_REMOTE_PACKET;\n"})}),"\n",(0,i.jsx)(n.h1,{id:"main-communication-modules",children:"Main Communication Modules"}),"\n",(0,i.jsx)(n.p,{children:"There are 4 Main Communication Modules in hwdbg:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Sending Module"}),"\n",(0,i.jsx)(n.li,{children:"Receiving Module"}),"\n",(0,i.jsx)(n.li,{children:"The Sender/Receiver Synchronization Module"}),"\n",(0,i.jsx)(n.li,{children:"item Interpreting Module"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"Since there is only one port shared with PS and PL has only one port to the BlockRAM, hwdbg cannot simultaneously read/write to the BlockRAM. Thus, the above modules are designed to handle these situations to avoid simultaneous sending and receiving, which can cause data corruption and invalid data in the BlockRAM. Once valid data is received, the interpreter module attempts to interpret the packet and may also send data as a result of interpretation."}),"\n",(0,i.jsx)(n.h1,{id:"raw-shared-channel-project-for-testing-artifacts",children:"Raw Shared Channel Project for Testing Artifacts"}),"\n",(0,i.jsx)(n.p,{children:"For testing artifacts, a shared PS <> PL project has been written to create a channel between the PS and the PL by sharing an 8 KB (can be customized) Block RAM (BRAM) as well as an interrupt line from PL to PS, and a GPIO line from PS to PL. The BRAM is made accessible for both PS and PL communication. The following figure depicts the high-level design of the PS <> PL shared channel in Vivado. \\"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{alt:"High-level Overview of PS &lt;&gt; PL Communication Over AXI Bus.",src:t(3869).A+"",width:"1421",height:"771"})})]})}function l(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(h,{...e})}):h(e)}},6377:(e,n,t)=>{t.d(n,{A:()=>i});const i=t.p+"assets/images/packet-memory-06a7fd13cc1aade0eb9097d61b100c7d.png"},3869:(e,n,t)=>{t.d(n,{A:()=>i});const i=t.p+"assets/images/ps-pl-shared-channel-0fbdbe5e98b1dada079e9c3fb063779a.jpg"},8453:(e,n,t)=>{t.d(n,{R:()=>o,x:()=>d});var i=t(6540);const r={},s=i.createContext(r);function o(e){const n=i.useContext(s);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function d(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:o(e.components),i.createElement(s.Provider,{value:n},e.children)}}}]);