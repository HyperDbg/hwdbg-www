<!doctype html>
<html lang="en" dir="ltr" class="docs-wrapper plugin-docs plugin-id-default docs-version-current docs-doc-page docs-doc-id-design" data-has-hydrated="false">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v3.2.0">
<title data-rh="true">Hardware Design | hwdbg</title><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:image" content="https://hwdbg.hyperdbg.org/img/social-card.png"><meta data-rh="true" name="twitter:image" content="https://hwdbg.hyperdbg.org/img/social-card.png"><meta data-rh="true" property="og:url" content="https://hwdbg.hyperdbg.org/docs/design"><meta data-rh="true" property="og:locale" content="en"><meta data-rh="true" name="docusaurus_locale" content="en"><meta data-rh="true" name="docsearch:language" content="en"><meta data-rh="true" name="docusaurus_version" content="current"><meta data-rh="true" name="docusaurus_tag" content="docs-default-current"><meta data-rh="true" name="docsearch:version" content="current"><meta data-rh="true" name="docsearch:docusaurus_tag" content="docs-default-current"><meta data-rh="true" property="og:title" content="Hardware Design | hwdbg"><meta data-rh="true" name="description" content="Here, the design consideration for different components of hwdbg is discussed."><meta data-rh="true" property="og:description" content="Here, the design consideration for different components of hwdbg is discussed."><link data-rh="true" rel="icon" href="/img/favicon.ico"><link data-rh="true" rel="canonical" href="https://hwdbg.hyperdbg.org/docs/design"><link data-rh="true" rel="alternate" href="https://hwdbg.hyperdbg.org/docs/design" hreflang="en"><link data-rh="true" rel="alternate" href="https://hwdbg.hyperdbg.org/docs/design" hreflang="x-default"><link rel="alternate" type="application/rss+xml" href="/blog/rss.xml" title="hwdbg RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/blog/atom.xml" title="hwdbg Atom Feed"><link rel="stylesheet" href="/assets/css/styles.73fed00b.css">
<script src="/assets/js/runtime~main.c8fba063.js" defer="defer"></script>
<script src="/assets/js/main.44e718bf.js" defer="defer"></script>
</head>
<body class="navigation-with-keyboard">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return localStorage.getItem("theme")}catch(t){}}();t(null!==e?e:"light")}(),function(){try{const c=new URLSearchParams(window.location.search).entries();for(var[t,e]of c)if(t.startsWith("docusaurus-data-")){var a=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(a,e)}}catch(t){}}()</script><div id="__docusaurus"><div role="region" aria-label="Skip to main content"><a class="skipToContent_fXgn" href="#__docusaurus_skipToContent_fallback">Skip to main content</a></div><nav aria-label="Main" class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Toggle navigation bar" aria-expanded="false" class="navbar__toggle clean-btn" type="button"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><div class="navbar__logo"><img src="/img/hyperdbg.png" alt="hwdbg" class="themedComponent_mlkZ themedComponent--light_NVdE"><img src="/img/hyperdbg.png" alt="hwdbg" class="themedComponent_mlkZ themedComponent--dark_xIcU"></div><b class="navbar__title text--truncate">hwdbg</b></a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/docs">Documentation</a><a href="https://hwdbg.hyperdbg.org/api" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">API</a><a href="https://github.com/HyperDbg/hwdbg-fpga" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">FPGA Boards</a></div><div class="navbar__items navbar__items--right"><a href="https://github.com/HyperDbg/hwdbg" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link header-github-link" aria-label="GitHub repository"></a><div class="toggle_vylO colorModeToggle_DEke"><button class="clean-btn toggleButton_gllP toggleButtonDisabled_aARS" type="button" disabled="" title="Switch between dark and light mode (currently light mode)" aria-label="Switch between dark and light mode (currently light mode)" aria-live="polite"><svg viewBox="0 0 24 24" width="24" height="24" class="lightToggleIcon_pyhR"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" class="darkToggleIcon_wfgR"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg></button></div><div class="navbarSearchContainer_Bca1"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div id="__docusaurus_skipToContent_fallback" class="main-wrapper mainWrapper_z2l0"><div class="docsWrapper_hBAB"><button aria-label="Scroll back to top" class="clean-btn theme-back-to-top-button backToTopButton_sjWU" type="button"></button><div class="docRoot_UBD9"><aside class="theme-doc-sidebar-container docSidebarContainer_YfHR"><div class="sidebarViewport_aRkj"><div class="sidebar_njMd"><nav aria-label="Docs sidebar" class="menu thin-scrollbar menu_SIkG"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/faq">Tutorial Intro</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/getting-started">Tutorial Intro</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/">Tutorial Intro</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/background">Background</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link menu__link--active" aria-current="page" href="/docs/design">Hardware Design</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/scripting">Script Engine &amp; Scripting Language</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/sensors">Debugging Sensors</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/tests">Evaluation</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/usecases">Hardware Debugging, Reversing &amp; Fuzzing</a></li></ul></nav></div></div></aside><main class="docMainContainer_TBSr"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_VOVn"><div class="docItemContainer_Djhp"><article><nav class="theme-doc-breadcrumbs breadcrumbsContainer_Z_bl" aria-label="Breadcrumbs"><ul class="breadcrumbs" itemscope="" itemtype="https://schema.org/BreadcrumbList"><li class="breadcrumbs__item"><a aria-label="Home page" class="breadcrumbs__link" href="/"><svg viewBox="0 0 24 24" class="breadcrumbHomeIcon_YNFT"><path d="M10 19v-5h4v5c0 .55.45 1 1 1h3c.55 0 1-.45 1-1v-7h1.7c.46 0 .68-.57.33-.87L12.67 3.6c-.38-.34-.96-.34-1.34 0l-8.36 7.53c-.34.3-.13.87.33.87H5v7c0 .55.45 1 1 1h3c.55 0 1-.45 1-1z" fill="currentColor"></path></svg></a></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item breadcrumbs__item--active"><span class="breadcrumbs__link" itemprop="name">Hardware Design</span><meta itemprop="position" content="1"></li></ul></nav><div class="tocCollapsible_ETCw theme-doc-toc-mobile tocMobile_ITEo"><button type="button" class="clean-btn tocCollapsibleButton_TO0P">On this page</button></div><div class="theme-doc-markdown markdown"><h1>Hardware Design</h1>
<p>Here, the design consideration for different components of hwdbg is discussed.</p>
<h1>Motivation for the Design</h1>
<p>The design of the debugger was driven by the need to address specific limitations in existing systems especially based on the constraints imposed in Xilinx FPGAs. The primary objective was to create a robust and efficient solution capable of handling high throughput while maintaining low latency to make hwdbg capable of handling signals with a high rate of frequency. Additionally, the design aimed to enhance scalability and reliability to meet the demands of modern hardware. By addressing these goals, the design seeks to bridge the gap between current capabilities and the evolving requirements of the industry.</p>
<h1>Challenges and Solutions</h1>
<p>During the design process, we encountered several significant challenges. One of the primary difficulties was ensuring the system&#x27;s ability to scale efficiently without compromising performance. To address this, we implemented a modular architecture that allows for seamless scaling by adding or removing components as needed. Another challenge was maintaining data consistency and integrity across PS/PL and possible external debugger. We overcame this by incorporating advanced synchronization mechanisms and error-checking protocols.</p>
<p>Several key design decisions were made to optimize the system&#x27;s performance and reliability. For instance, we chose a microservices architecture over a monolithic approach to enhance scalability and maintainability. This decision was based on the need for flexibility in deploying and updating individual components without affecting the entire system. In the coming sections, the design constraints and decisions of hwdbg are discussed.</p>
<h1>Debugging Input/Output Pins</h1>
<p>There are five divisions of pins in hwdbg.</p>
<ul>
<li><strong>Chip pins</strong>: Contains the clock signal [<em>clock</em>], reset [<em>reset</em>], and chip enable [<em>io_en</em>] all as inputs</li>
<li><strong>Interrupt lines</strong>: Contains [<em>io_plInSignal</em>] as PS to PL signal input, and [<em>io_psOutInterrupt</em>] as PL to PS interrupt output</li>
<li><strong>BRAM ports</strong>: Contains [<em>io_rdData</em>] as read data input, [<em>io_rdWrAddr</em>] as read/write address output, [<em>io_wrEna</em>] as enable writing, and [<em>io_wrData</em>] as write data all as output</li>
<li><strong>Input pins</strong>: Contains [<em>io_inputPin0...n</em>] as input pins</li>
<li><strong>Output pins</strong>: Contains [<em>io_outputPin0..n</em>] as output pins</li>
</ul>
<p>These pins are also illustrated in figure below.</p>
<p><img decoding="async" loading="lazy" alt="Input/Output Pins in hwdbg." src="/assets/images/chip-in-out-b856a8bb0f4df05fb2541b9531cf2305.jpg" width="1583" height="1033" class="img_ev3q"></p>
<table><thead><tr><th><strong>Division</strong></th><th><strong>Pin</strong></th><th><strong>Description</strong></th></tr></thead><tbody><tr><td>Chip Pins</td><td>clock, reset, io_en</td><td>Clock signal (input), Reset signal (input), Chip enable signal (input)</td></tr><tr><td>Interrupt Lines</td><td>io_plInSignal, io_psOutInterrupt</td><td>PS to PL signal (input), PL to PS interrupt (output)</td></tr><tr><td>BRAM Ports</td><td>io_rdData, io_rdWrAddr, io_wrEna, io_wrData</td><td>Read data (input), Read/write address (output), Enable writing (output), Write data (output)</td></tr><tr><td>Input Pins</td><td>io_inputPin0...n (customizable)</td><td>Input pins (input)</td></tr><tr><td>Output Pins</td><td>io_outputPin0...n (customizable)</td><td>Output pins (output)</td></tr></tbody></table>
<h1>Design Flow</h1>
<p>Figure below shows the flowchart of hwdbg from design to the bitstream generation for FPGA implementation. It starts with HDL code, which can be written in Verilog (.SV) or SystemVerilog (.V). This code is then synthesized by Xilinx Vivado into an RTL netlist (.rtl).</p>
<p><img decoding="async" loading="lazy" alt="The High-level View of hwdbg Hardware Generator for FPGA/ASIC Design.~\citegorgin2024hardware" src="/assets/images/high-level-hardware-stack-dd24d6c4591ec8a1cc46c89a6d44e98b.jpg" width="1112" height="1776" class="img_ev3q"></p>
<p>Next, the RTL netlist is simulated using a simulator like ModelSim<code>~\cite{ModelSim}</code>. This simulation helps to ensure that the design is functioning as expected. After simulation, the design is translated into a bitstream file (.bit) using Vivado<code>~\cite{VivadoX}</code>. This bitstream file is then loaded onto the FPGA development board.</p>
<p>The FPGA development board contains a programmable logic device (PLD) that can be configured to implement the design. The bitstream file tells the PLD how to connect its internal logic blocks to implement the desired functionality.</p>
<p>The FPGA development board also includes a processor system (PS) that can be used to control the PLD. The PS and PLD can communicate with each other through a shared channel. The PS can also communicate with the outside world through the chip pins.</p>
<h1>Raw Shared Channel Project for Testing Artifacts</h1>
<p>For testing artifacts, a shared PS &lt;&gt; PL project has been written to create a channel between the PS and the PL by sharing an 8 KB (can be customized) Block RAM (BRAM) as well as an interrupt line from PL to PS, and a GPIO line from PS to PL. The BRAM is made accessible for both PS and PL communication (See Section <code>\ref{sec:bram_sim}</code>). The following figure depicts the high-level design of the PS &lt;&gt; PL shared channel in Vivado. \</p>
<p><img decoding="async" loading="lazy" alt="High-level Overview of PS &amp;lt;&amp;gt; PL Communication Over AXI Bus." src="/assets/images/ps-pl-shared-channel-0fbdbe5e98b1dada079e9c3fb063779a.jpg" width="1421" height="771" class="img_ev3q"></p>
<h1>Communication Protocols</h1>
<p>The communication protocol follows a packet-based design between sender and receiver. These packets contain special mandatory headers to check for the integrity of the packet and prevent communication errors as well as specifying which component in the debugger/debuggee is responsible for handling the receiving packet and the corresponding action. To achieve this, a communication protocol is designed, similar to the one used in <strong>HyperDbg</strong>, enabling data exchange through shared memory.</p>
<p>For the communication between PL and PS, the following structure is used.</p>
<p><img decoding="async" loading="lazy" alt="The Format of Action Request Packets from PS &amp;lt;&amp;gt; PL Communication." src="/assets/images/packet-memory-06a7fd13cc1aade0eb9097d61b100c7d.png" width="962" height="221" class="img_ev3q"></p>
<p>This design uses four mandatory fields. The first is the <code>checksum</code> of the incoming/outgoing packet primarily used for checking whether the packet is modified communication problems. The second field is the <code>indicator</code> of the packet which is used to identify that the packet is related to a HyperDbg-compatible interpreter. The following table shows an example of a valid indicator.</p>
<table><thead><tr><th><strong>Constant Name</strong></th><th><strong>Value</strong></th></tr></thead><tbody><tr><td>INDICATOR_OF_HYPERDBG_PACKET</td><td>0x4859504552444247</td></tr></tbody></table>
<p>The third field is <code>TypeOfThePacket</code>. Two exclusive packet types are owned by hwdbg for sending data from debugger (PS) to debugged (PL) and from debuggee (PL) to debugger (PS).</p>
<table><thead><tr><th><strong>Packet Type</strong></th><th><strong>Description</strong></th></tr></thead><tbody><tr><td>DEBUGGER_TO_DEBUGGEE_EXECUTE_ON_VMX_ROOT</td><td>Debugger to debuggee (VMX-root)</td></tr><tr><td>DEBUGGER_TO_DEBUGGEE_EXECUTE_ON_USER_MODE</td><td>Debugger to debuggee (user-mode)</td></tr><tr><td>DEBUGGEE_TO_DEBUGGER</td><td>Debuggee to debugger (user/kernel &amp; VMX-root)</td></tr><tr><td>DEBUGGER_TO_DEBUGGEE_HARDWARE_LEVEL</td><td>Debugger to debuggee (hardware), used in hwdbg</td></tr><tr><td>DEBUGGEE_TO_DEBUGGER_HARDWARE_LEVEL</td><td>Debuggee to debugger (hardware), used in hwdbg</td></tr></tbody></table>
<p>The communication structure is synchronized between hwdbg (written in Scala) and <strong>HyperDbg</strong> (written in C) and it is demonstrated as follows:</p>
<div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">/**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * @brief The structure of remote packets in HyperDbg</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> *</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">typedef struct _DEBUGGER_REMOTE_PACKET</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    BYTE                                    Checksum;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    UINT64                                  Indicator; /* Shows the type of the packet */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    DEBUGGER_REMOTE_PACKET_TYPE             TypeOfThePacket;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    DEBUGGER_REMOTE_PACKET_REQUESTED_ACTION RequestedActionOfThePacket;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">} DEBUGGER_REMOTE_PACKET, *PDEBUGGER_REMOTE_PACKET;</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<h1>Main Communication Modules</h1>
<p>There are 4 Main Communication Modules in hwdbg:</p>
<ul>
<li>Sending Module</li>
<li>Receiving Module</li>
<li>The Sender/Receiver Synchronization Module</li>
<li>item Interpreting Module</li>
</ul>
<p>Since there is only one port shared with PS and PL has only one port to the BlockRAM, hwdbg cannot simultaneously read/write to the BlockRAM. Thus, the above modules are designed to handle these situations to avoid simultaneous sending and receiving, which can cause data corruption and invalid data in the BlockRAM. Once valid data is received, the interpreter module attempts to interpret the packet and may also send data as a result of interpretation.</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="sending-module">Sending Module<a href="#sending-module" class="hash-link" aria-label="Direct link to Sending Module" title="Direct link to Sending Module">​</a></h2>
<p>This module is responsible for transmitting data from the hardware debugger (hwdbg) or the Programmable Logic (PL) to the Processor System (PS). It handles the process of packaging the data into packets suitable for transmission and sending them out through the designated port. Additionally, it adds different headers and manages any necessary handshaking protocols, and adjusts mandatory fields to ensure successful data transmission.</p>
<p><img decoding="async" loading="lazy" alt="The FSM of How Sending Module Works." src="/assets/images/sending-data-fsm-65b950abfe8caca88be2eacb931b73b5.jpg" width="2188" height="1987" class="img_ev3q"></p>
<p>This module ensures the orderly and correct transmission of data from the module to the designated receiver. The state machine of the module begins in the <code>sIdle</code> state, where it initializes key variables and awaits the signal to begin sending data (<code>beginSendingBuffer = 1</code>). Once this signal is received, the sender module transitions to the <code>sWriteChecksum</code> state, where it writes the checksum offset and initializes the data transfer process.</p>
<p>Next, to prepare headers it moves to various states such as <code>sWriteIndicator</code>, <code>sWriteTypeOfThePacket</code>, and <code>sWriteRequestedActionOfThePacket</code>. In these states, the module writes specific pieces of data to designated addresses, preparing the data packet for transmission. When there is no new header data to send, the FSM transitions to the <code>sWaitToGetData</code> state, where it awaits the arrival of valid data (<code>dataValidInput = 1</code>). Once valid data is received, the FSM moves to the <code>sSendData</code> state, where the actual data transmission occurs. If no more data is available (<code>noNewDataSender = 1</code>), the FSM transitions to the <code>sDone</code> state, signaling the completion of the sending process (<code>finishedSendingBuffer = 1</code>) and setting the interrupt for the processor system (<code>psOutInterrupt = 1</code>). This module ensures data is sent accurately, avoiding conflicts and maintaining the integrity of the data in the BlockRAM.</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="receiving-module">Receiving Module<a href="#receiving-module" class="hash-link" aria-label="Direct link to Receiving Module" title="Direct link to Receiving Module">​</a></h2>
<p>The receiving module is responsible for capturing incoming data from PS and passing it to the hwdbg for further processing. It monitors the designated port (PS to PL shared line) for incoming data packets, retrieves them, checks for validity, and forwards them to the appropriate components within the debugger for interpretation or storage.</p>
<p><img decoding="async" loading="lazy" alt="The FSM of How Receiving Module Works." src="/assets/images/receiver-fsm-c848362e6eae7fd2fec70f46fe8551f0.jpg" width="2192" height="2192" class="img_ev3q"></p>
<p>The above figure depicts the Moore FSM of the receiving module for the sequence of operations required to process incoming data packets. The process begins in the <code>sIdle</code> state, where the module awaits a valid signal (<code>pllInSignal = 1</code>) to transition to the next states for reading packet data. Upon receiving the signal, the FSM moves to <code>sReadChecksum</code> to verify the integrity of the data packet by reading the checksum from the specified offset. Following a successful checksum read, the FSM transitions to <code>sReadIndicator</code> to read an indicator value that determines the type of packet being processed.</p>
<p>The FSM proceeds to the <code>sReadTypeOfThePacket</code> state, where it identifies the packet type. Depending on the validity of the indicator, the FSM either moves to <code>sReadRequestedActionOfThePacket</code> to fetch the specific action requested by the packet or reverts to the <code>sIdle</code> state if the indicator is invalid. Valid packets lead to the <code>sRequestedActionIsValid</code> state, where the requested action is confirmed, and the address for reading the next data is set. The FSM then cycles through states such as <code>sReadActionBuffer</code> and <code>sWaitToReadActionBuffer</code>, handling the data reception and buffering process. The cycle continues until all data is read, eventually transitioning to the <code>sDone</code> state, indicating the data reception&#x27;s completion.</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="the-senderreceiver-synchronization-module">The Sender/Receiver Synchronization Module<a href="#the-senderreceiver-synchronization-module" class="hash-link" aria-label="Direct link to The Sender/Receiver Synchronization Module" title="Direct link to The Sender/Receiver Synchronization Module">​</a></h2>
<p>This module plays a crucial role in ensuring that the sending and receiving operations within the hwdbg occur without conflicts. It manages the timing and coordination between the sending and receiving modules, preventing them from attempting to access the shared resources simultaneously. Other than that, based on the fact that Xilinx FPGAs are manufactured with BRAMs with two ports, one port is shared with PS, and the other one is shared with PL, thus, no two modules (in PL) can use a single port simultaneously. By enforcing synchronization, this module helps prevent data corruption between multiple modules (in PL) and ensures the integrity of communications between the debugger and the PL/PS.</p>
<p><img decoding="async" loading="lazy" alt="The FSM of How Sender/Receiver Synchronization Module Works." src="/assets/images/send-receive-data-synchronizer-fsm-165fd47925bf412a6fea9f205eb7e52e.jpg" width="2425" height="1533" class="img_ev3q"></p>
<p><img decoding="async" loading="lazy" alt="The Wave Demonstration of How Sender/Receiver Synchronization Module Works." src="/assets/images/wavedrom-synch-module-4978b53102338641631f0d25d814c0fd.jpg" width="2875" height="656" class="img_ev3q"></p>
<p>The diagram illustrates the Moore FSM and the figure is the waveform of the synchronizer module in the hwdbg hardware debugger, responsible for coordinating the sending and receiving of data. The FSM begins in the <code>sIdle</code> state, where all control signals (<code>wrEna</code>, <code>rdWrAddr</code>, <code>wrData</code>, <code>rdData</code>) are initialized to zero, awaiting a trigger to commence data operations. When the <code>pllInSignal</code> is asserted (<code>pllInSignal = 1</code>), the FSM transitions to the <code>sReceiver</code> state, where it performs data reading tasks. In this state, the address for reading is set (<code>rdWrAddr = requested addr</code>), and the data to be read is managed. The module remains in <code>sReceiver</code> until the <code>finishedReceivingBuffer</code> signal is set, indicating that the data reception process is complete.</p>
<p>Following the reception, the FSM moves back to the <code>sIdle</code> state until conditions for sending data are met (<code>beginSendingData = 1</code> and <code>pllInSignal = 0</code>). Once these conditions are satisfied, the FSM transitions to the <code>sSender</code> state. In <code>sSender</code>, the module is configured to enable writing (<code>wrEna = sender value</code>), set the address for writing (<code>rdWrAddr = requested addr</code>), and prepare the data to be written (<code>wrData = Data to Write</code>). The FSM remains in this state until the <code>finishedSendingBuffer</code> signal is asserted, which marks the completion of the data transmission. Finally, the FSM returns to the <code>sIdle</code> state, ready for the next cycle of operations. This synchronized process ensures efficient and orderly data handling, maintaining the integrity and reliability of data transactions within the hardware debugger. Note that in hwdbg, receiving command precedes sending data.</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="interpreting-module">Interpreting Module<a href="#interpreting-module" class="hash-link" aria-label="Direct link to Interpreting Module" title="Direct link to Interpreting Module">​</a></h2>
<p>Once valid data is received from either the PS, the interpreting module takes charge of analyzing the incoming packets. It decodes the received data, interprets its meaning or purpose, and triggers any necessary actions or responses within the hwdbg. This module involves parsing incoming commands, executing debugging operations, or generating responses to be sent back to the PS.</p>
<p><img decoding="async" loading="lazy" alt="The FSM of How Interpreter Module Works." src="/assets/images/interpreter-fsm-27b8936a5cf26d12c7a0f44ac3869405.jpg" width="2608" height="1600" class="img_ev3q"></p>
<p>The diagram (See Figure <code>\ref{fig:interpreter_fsm}</code>) illustrates the Moore FSM and Figure <code>\ref{fig:interpreter_wave}</code> demonstrates the waveform of the interpreter module of the hwdbg hardware debugger. This module is designed to process incoming data packets and generate appropriate responses based on the actions requested by these packets. Initially, the FSM is in the <code>sIdle</code> state, where it remains until a valid packet input is received from the receiver module (<code>requestedActionOfThePacketInputValid = 1</code>). In this state, no new data is being received or sent by the interpreter (<code>noNewDataReceiver = 0</code>, <code>noNewDataSender = 0</code>).</p>
<p><img decoding="async" loading="lazy" alt="The Wave Demonstration of How Interpreter Module Works." src="/assets/images/wavedrom-interpreter-270bce1b38cbdfb96f99a39b0efb5e1d.jpg" width="3188" height="469" class="img_ev3q"></p>
<p>Upon detecting a valid packet input, the FSM transitions to the receiving (<code>sNewActionReceived</code>) state. Here, the module interprets the requested action and prepares the response (<code>requestedActionOfThePacketOutput = adequate response</code>). If the action is invalid, an error flag (<code>lastError = if invalid action received</code>) is set. After processing the action, the FSM moves to the <code>sSendResponse</code> state, where it prepares to send the response data. In this state, the module sets signals indicating it is ready to send data (<code>noNewDataReceiver = 1</code>, <code>beginSendingBuffer = 1</code>) and the data to be sent is made available (<code>sendingData = module data</code>). If further synchronization is required, the FSM ensures that the data is valid and waits for the buffer to be ready (<code>sendWaitForBuffer = 0</code>).</p>
<p>Once the response data has been sent, the current FSM transitions to the <code>sDone</code> state, where it updates the read/write address (<code>rdWrAddr = type of packet offset</code>) and signals that the receiving and sending processes are complete (<code>noNewDataReceiver = 1</code>, <code>noNewDataSender = 1</code>). Finally, the FSM returns to the <code>sIdle</code> state, ready to process the next incoming packet.</p>
<h1>BlockRAM (BRAM) Simulator</h1>
<p>To test and debug the hwdbg effectively, a BlockRAM simulator module was developed, filled with sample testing data from a file. As the Chisel language<code>~\cite{bachrach2012chisel}</code> does not directly support BlockRAM components, despite its support for SRAM modules, an 8 KB flip-flop module was created to simulate the behavior of BlockRAM. At the moment 8 KB was proved to be enough to support most of the hwdbg tasks. This module features input/output ports similar to those of Xilinx FPGA BlockRAMs, ensuring compatibility and accurate simulation. The delay characteristics of the BlockRAM were also emulated which allows the testing module to initialize the flip-flops with test data sent from the PS to PL.</p>
<p>In the simulation, the first half of the BlockRAM is dedicated to buffers for data transfer from PS to PL, while the second half is reserved for data transfer from PL to PS. The BlockRAM is divided into two halves to ensure that both the PL and PS do not simultaneously overwrite each other&#x27;s buffer. During execution, the testing module initializes the flip-flops with test data, simulating the conditions of actual hardware interactions. After the debugger completes its operations, the second half of the BlockRAM is filled with the output data generated by the PL.</p>
<p>To verify the functionality and correctness of the hwdbg, the data in the BlockRAM is displayed and written to a file post-execution. This data is then interpreted based on the communication protocol, with each field&#x27;s value being shown and separated for clarity. The simulation was executed using cocotb<code>~\cite{cocotb}</code>, with Verilator <code>\cite{verilator}</code> and Icarus<code>~\cite{icarus}</code> serving as the backend tools. This comprehensive testing framework not only validates the hwdbg but also provides insights into the communication and data handling processes.</p>
<p>The following listing is an example of PS/PL shared BlockRAM contents shown in the BRAM simulator.</p>
<div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">Number of clock cycles spent in debuggee (PL): 0</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Number of clock cycles spent in debuggee (PL): 10</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Number of clock cycles spent in debuggee (PL): 20</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Debuggee (PL) interrupted Debugger (PS)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">===============================</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Content of BRAM after emulation:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Address of PL to PS communication: mem_128</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">PS to PL area:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">mem_0:   00000000   | Checksum</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">mem_1:   00000000   | Checksum</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">mem_2:   52444247   | Indicator</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">mem_3:   48595045   | Indicator</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">mem_4:   00000004   | TypeOfThePacket</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">mem_5:   00000002   | RequestedActionOfThePacket</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">mem_6:   00000000   | Start of Optional Data</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">mem_7:   00000000</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">PL to PS area:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">mem_128: 00000000   | Checksum</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">mem_129: 00000000   | Checksum</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">mem_130: 52444247   | Indicator</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">mem_131: 48595045   | Indicator</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">mem_132: 00000005   | TypeOfThePacket</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">mem_133: 00000003   | RequestedActionOfThePacket</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">mem_134: 00000003   | Start of Optional Data</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">mem_135: 0000000c</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">mem_136: 00000009</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">mem_137: 0000000b</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">mem_138: 00000000</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">...</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div></div><footer class="theme-doc-footer docusaurus-mt-lg"><div class="row margin-top--sm theme-doc-footer-edit-meta-row"><div class="col"><a href="https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/design.md" target="_blank" rel="noopener noreferrer" class="theme-edit-this-page"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_Z9Sw" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div><div class="col lastUpdated_JAkA"></div></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Docs pages"><a class="pagination-nav__link pagination-nav__link--prev" href="/docs/background"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">Background</div></a><a class="pagination-nav__link pagination-nav__link--next" href="/docs/scripting"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">Script Engine &amp; Scripting Language</div></a></nav></div></div><div class="col col--3"><div class="tableOfContents_bqdL thin-scrollbar theme-doc-toc-desktop"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#sending-module" class="table-of-contents__link toc-highlight">Sending Module</a></li><li><a href="#receiving-module" class="table-of-contents__link toc-highlight">Receiving Module</a></li><li><a href="#the-senderreceiver-synchronization-module" class="table-of-contents__link toc-highlight">The Sender/Receiver Synchronization Module</a></li><li><a href="#interpreting-module" class="table-of-contents__link toc-highlight">Interpreting Module</a></li></ul></div></div></div></div></main></div></div></div><footer class="footer footer--dark"><div class="container container-fluid"><div class="row footer__links"><div class="col footer__col"><div class="footer__title">Docs</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/docs/getting-started">Getting Started</a></li><li class="footer__item"><a href="https://hwdbg.hyperdbg.org/api" target="_blank" rel="noopener noreferrer" class="footer__link-item">API</a></li><li class="footer__item"><a class="footer__link-item" href="/docs/faq">FAQs</a></li></ul></div><div class="col footer__col"><div class="footer__title">Community</div><ul class="footer__items clean-list"><li class="footer__item"><a href="https://hyperdbg.org" target="_blank" rel="noopener noreferrer" class="footer__link-item">HyperDbg<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li class="footer__item"><a href="https://t.me/HyperDbg" target="_blank" rel="noopener noreferrer" class="footer__link-item">Telegram<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li class="footer__item"><a href="https://infosec.exchange/@hyperdbg" target="_blank" rel="noopener noreferrer" class="footer__link-item">Mastodon<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li class="footer__item"><a href="https://youtube.com/c/HyperDbg" target="_blank" rel="noopener noreferrer" class="footer__link-item">YouTube<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li class="footer__item"><a href="https://twitter.com/HyperDbg" target="_blank" rel="noopener noreferrer" class="footer__link-item">Twitter<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div><div class="col footer__col"><div class="footer__title">More</div><ul class="footer__items clean-list"><li class="footer__item"><a href="https://github.com/HyperDbg/hwdbg" target="_blank" rel="noopener noreferrer" class="footer__link-item">hwdbg GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li class="footer__item"><a href="https://research.hyperdbg.org" target="_blank" rel="noopener noreferrer" class="footer__link-item">HyperDbg Research<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li class="footer__item"><a href="https://github.com/HyperDbg" target="_blank" rel="noopener noreferrer" class="footer__link-item">HyperDbg GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li class="footer__item"><a href="https://docs.hyperdbg.org" target="_blank" rel="noopener noreferrer" class="footer__link-item">HyperDbg Documentation<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li class="footer__item"><a href="https://github.com/HyperDbg/HyperDbg" target="_blank" rel="noopener noreferrer" class="footer__link-item">HyperDbg Debugger<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2024 HyperDbg Developers. Built with Docusaurus.</div></div></div></footer></div>
</body>
</html>